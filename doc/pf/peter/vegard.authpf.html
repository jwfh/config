<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>An open, yet tightly guarded wireless network with authpf</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="Firewalling with OpenBSD's PF packet filter
  "
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Setting up a simple wireless network"
HREF="wireless.simple.setup.html"><LINK
REL="NEXT"
TITLE="Turning away the brutes"
HREF="bruteforce.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="docbook.css"><meta
http-equiv="Content-Type"
content="text/html; charset=ISO-8859-1"></HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Firewalling with OpenBSD's PF packet filter</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="wireless.simple.setup.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="bruteforce.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="VEGARD.AUTHPF"
></A
>An open, yet tightly guarded wireless network with <SPAN
CLASS="APPLICATION"
>authpf</SPAN
></H1
><P
>As always, there are other ways to configure the security of your
wireless network than the one we have just seen.  What little
protection WEP encryption offers, security professionals tend to agree
is barely enough to signal to an attacker that you do not intend to
let all and sundry use your network resources.</P
><P
>A different approach appeared one day in my mail as a message from my
friend Vegard Engen, who told me he had been setting up
<SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/authpf"
TARGET="_top"
>authpf</A
></SPAN
>.  <SPAN
CLASS="APPLICATION"
>authpf</SPAN
>
is a user shell which lets you load PF rules on a per user basis,
effectively deciding which user gets to do what.  </P
><P
>To use <SPAN
CLASS="APPLICATION"
>authpf</SPAN
>, you create users with the
<SPAN
CLASS="APPLICATION"
>authpf</SPAN
> program as their shell.  In order to
get network access, the user logs in to the gateway using
<SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/ssh"
TARGET="_top"
>ssh</A
></SPAN
>.  Once the user successfully completes
<SPAN
CLASS="APPLICATION"
>ssh</SPAN
> authentication,
<SPAN
CLASS="APPLICATION"
>authpf</SPAN
> loads the rules you have defined for
the user or the relevant class of users. </P
><P
>These rules, which apply to the IP address which the user logged in
from, stay loaded and in force for as long as the user stays logged in
via the <SPAN
CLASS="APPLICATION"
>ssh</SPAN
> connection.  Once the
connection is terminated, the rules are unloaded, and in most
scenarios all non-<SPAN
CLASS="APPLICATION"
>ssh</SPAN
> traffic from the
user's IP address is denied.  With a reasonable setup, only traffic
originated by authenticated users will be let through.</P
><P
>Vegard's annotated config follows below.  His wireless network is
configured without WEP encryption, preferring to handle the security
side of things via PF and <SPAN
CLASS="APPLICATION"
>authpf</SPAN
>:</P
><P
>Start with creating an empty <TT
CLASS="FILENAME"
>/etc/authpf/authpf.conf</TT
>. 
It needs to be there for <SPAN
CLASS="APPLICATION"
>authpf</SPAN
> to work, but 
doesn't actually need any content.</P
><P
>The other relevant bits of <TT
CLASS="FILENAME"
>/etc/pf.conf</TT
> follow. First, interface macros:</P
><PRE
CLASS="PROGRAMLISTING"
>int_if="sis1"
ext_if="sis0"
wi_if = "wi0"</PRE
><P
>The use of this address will become apparent later:</P
><PRE
CLASS="PROGRAMLISTING"
>auth_web="192.168.27.20"</PRE
><P
>The traditional authpf table</P
><PRE
CLASS="PROGRAMLISTING"
>table &lt;authpf_users&gt; persist </PRE
><P
>We could put the NAT part in <TT
CLASS="FILENAME"
>authpf.rules</TT
>, but keeping it in the main
<TT
CLASS="FILENAME"
>pf.conf</TT
> doesn't hurt:</P
><PRE
CLASS="PROGRAMLISTING"
>match out on $ext_if from $int_if:network nat-to ($ext_if)</PRE
><P
>or in pre-OpenBSD 4.7 syntax:</P
><PRE
CLASS="PROGRAMLISTING"
>nat on $ext_if from $wi_if:network to any -&#62; ($ext_if)</PRE
><P
>Redirects to let traffic reach servers on the internal net. These
could be put in <TT
CLASS="FILENAME"
>authpf.rules</TT
> too, but since they
do not actually provide access without pass rules, keeping them here
won't hurt anything.</P
><PRE
CLASS="PROGRAMLISTING"
>match in on $wi_if proto tcp from any to $myaddr port $tcp_in rdr-to $server
match in on $wi_if proto udp from any to $myaddr port $udp_in rdr-to $server</PRE
><P
>or in pre-OpenBSD 4.7 syntax:</P
><PRE
CLASS="PROGRAMLISTING"
>rdr on $wi_if proto tcp from any to $myaddr port $tcp_in -&#62; $server
rdr on $wi_if proto udp from any to $myaddr port $udp_in -&#62; $server</PRE
><P
>The next redirect sends all web traffic from non authenticated users
to port 80 on <KBD
CLASS="USERINPUT"
>$auth_web</KBD
>.  In Vegard's setup,
this is a web server which displays contact info for people who
stumble onto the wireless net.  In a commercial setting, this would be
where you would put something which could handle credit cards and
create users.</P
><PRE
CLASS="PROGRAMLISTING"
>match in on on $wi_if proto tcp from ! &lt;authpf_users&gt; port 80 rdr-to $auth_web</PRE
><P
>or in pre-OpenBSD 4.7 syntax:</P
><PRE
CLASS="PROGRAMLISTING"
>rdr on $wi_if proto tcp from ! &lt;authpf_users&gt; to any \
 port 80 -&#62; $auth_web</PRE
><P
>Also make sure you have the <KBD
CLASS="USERINPUT"
>authpf</KBD
> anchor:</P
><PRE
CLASS="PROGRAMLISTING"
>anchor "authpf/*"</PRE
><P
>in pre-OpenBSD 4.7 PF, you need separate anchors in order to activate nat, binat or redirects in authpf:</P
><PRE
CLASS="PROGRAMLISTING"
>nat-anchor "authpf/*"
binat-anchor "authpf/*"
rdr-anchor "authpf/*"</PRE
><P
>On to the filtering rules, we start with a sensible default</P
><PRE
CLASS="PROGRAMLISTING"
>block all</PRE
><P
>Other global, user independent rules would go here. Next for the
authpf anchor, we make sure non-authenticated users connecting to the
wireless interface get redirected to <KBD
CLASS="USERINPUT"
>$auth_web</KBD
></P
><PRE
CLASS="PROGRAMLISTING"
>anchor "authpf/*" in on wi0

pass in on $wi_if inet proto tcp from any to $auth_web \
 port 80 keep state</PRE
><P
>There are three things we want anyway on the wireless interface:
Name service (DNS), DHCP and SSH in to the gateway.  Three rules
do the trick</P
><PRE
CLASS="PROGRAMLISTING"
>pass in on $wi_if inet proto udp from any port 53 keep state

pass in on $wi_if inet proto udp from any to $wi_if port 67

pass in on $wi_if inet proto tcp from any to $wi_if \
 port 22 keep state</PRE
><P
>Next up, the we define the rules which get loaded for all users who log in with
their shell set to <TT
CLASS="FILENAME"
>/usr/sbin/authpf</TT
>. These rules go in 
<TT
CLASS="FILENAME"
>/etc/authpf/authpf.rules</TT
>,</P
><PRE
CLASS="PROGRAMLISTING"
>int_if = "sis1"
ext_if = "sis0"
wi_if = "wi0"
server = "192.168.27.15"
myaddr = "213.187.n.m"

# Services which live on the internal network 
# and need to be accessible
tcp_services = "{ 22, 25, 53, 80, 110, 113, 995 }"
udp_services = "{ 53 }"
tcp_in = " { 22, 25, 53, 80, 993, 2317, pop3}"
udp_in = "{ 53 }"

# Pass traffic to elsewhere, that is the outside world
pass in on $wi_if inet from &lt;authpf_users&gt; to ! $int_if:network \
   keep state

# Let authenticated users use services on 
# the internal network.

pass in on $wi_if inet proto tcp from &lt;authpf_users&gt; to $server \
  port $tcp_in keep state
pass in on $wi_if inet proto udp from &lt;authpf_users&gt; to $server \
  port $udp_in keep state

# Also pass to external address. This means you can access 
# internal services on external addresses.

pass in on $wi_if inet proto tcp from &lt;authpf_users&gt; to $myaddr \
    port $tcp_in keep state
pass in on $wi_if inet proto udp from &lt;authpf_users&gt; to $myaddr \
    port $udp_in keep state</PRE
><P
>At this point we have an open net where anybody can connect and get an
IP address from DHCP.  All HTTP requests from non-authenticated users
get redirected to port 80 on 192.168.27.20, which is a server on the
internal net where all requests are answered with the same page, which
displays contact info in case you want to be registered and be allowed
to use the net.</P
><P
>You are allowed to ssh in to the gateway. Users with valid user IDs
and passwords get rule sets with appropriate pass rules loaded for
their assigned IP address. </P
><P
>We can fine tune this even more by making
user specific rules in <TT
CLASS="FILENAME"
>/etc/authpf/users/$user/authpf.rules</TT
>. Per user
rules can use the $user_ip macro for the user's IP address. For
example, if I want to give myself unlimited access, create the
following <TT
CLASS="FILENAME"
>/etc/authpf/users/vegard/authpf.rules</TT
>:</P
><PRE
CLASS="PROGRAMLISTING"
>wi_if="wi0"
pass in on $wi_if from $user_ip to any keep state</PRE
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="wireless.simple.setup.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="bruteforce.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Setting up a simple wireless network</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Turning away the brutes</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>