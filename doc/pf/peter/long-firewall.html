<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Firewalling with OpenBSD's PF packet filter
  </TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><META
NAME="KEYWORD"
CONTENT="firewall"><META
NAME="KEYWORD"
CONTENT="firewalls"><META
NAME="KEYWORD"
CONTENT="firewalling"><META
NAME="KEYWORD"
CONTENT="OpenBSD"><META
NAME="KEYWORD"
CONTENT="OpenBSD PF"><META
NAME="KEYWORD"
CONTENT="OpenBSD packet filter"><META
NAME="KEYWORD"
CONTENT="OpenBSD firewall"><META
NAME="KEYWORD"
CONTENT="OpenBSD firewalling"><META
NAME="KEYWORD"
CONTENT="OpenBSD firewalling tutorial"><META
NAME="KEYWORD"
CONTENT="BSD firewalling tutorial"><META
NAME="KEYWORD"
CONTENT="firewalling tutorial"><META
NAME="KEYWORD"
CONTENT="OpenBSD packet filter tutorial"><META
NAME="KEYWORD"
CONTENT="OpenBSD PF tutorial"><META
NAME="KEYWORD"
CONTENT="FreeBSD PF tutorial"><META
NAME="KEYWORD"
CONTENT="NetBSD PF tutorial"><META
NAME="KEYWORD"
CONTENT="FreeBSD"><META
NAME="KEYWORD"
CONTENT="FreeBSD PF"><META
NAME="KEYWORD"
CONTENT="FreeBSD firewall"><META
NAME="KEYWORD"
CONTENT="FreeBSD firewalling"><META
NAME="KEYWORD"
CONTENT="NetBSD"><META
NAME="KEYWORD"
CONTENT="NetBSD firewall"><META
NAME="KEYWORD"
CONTENT="NetBSD firewalling"><META
NAME="KEYWORD"
CONTENT="firewalling"><META
NAME="KEYWORD"
CONTENT="packet filter"><META
NAME="KEYWORD"
CONTENT="packet filter tutorial"><META
NAME="KEYWORD"
CONTENT="PF"><META
NAME="KEYWORD"
CONTENT="PF tutorial"><META
NAME="KEYWORD"
CONTENT="network"><META
NAME="KEYWORD"
CONTENT="networking"><META
NAME="KEYWORD"
CONTENT="network firewall"><META
NAME="KEYWORD"
CONTENT="network firewalling"><META
NAME="KEYWORD"
CONTENT="network security"><META
NAME="KEYWORD"
CONTENT="internet firewall"><META
NAME="KEYWORD"
CONTENT="internet protocol"><META
NAME="KEYWORD"
CONTENT="internet security"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="docbook.css"><meta
http-equiv="Content-Type"
content="text/html; charset=ISO-8859-1"></HEAD
><BODY
CLASS="BOOK"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="AEN1"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>Firewalling with OpenBSD's PF packet filter</A
></H1
><H3
CLASS="AUTHOR"
><A
NAME="AEN40"
></A
>Peter N. M. Hansteen</H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
><CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:peter@bsdly.net"
>peter@bsdly.net</A
>&#62;</CODE
></P
></DIV
></DIV
><P
CLASS="COPYRIGHT"
>Copyright &copy; 2005 - 2017 Peter N. M. Hansteen</P
><DIV
CLASS="LEGALNOTICE"
><P
></P
><A
NAME="AEN52"
></A
><P
>This document is &copy; Copyright 2005 - 2017, Peter N. M. Hansteen. All rights reserved.</P
><P
>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.</P
></LI
><LI
><P
>Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.</P
></LI
></OL
><P
>THIS DOCUMENTATION IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.</P
><P
>The document is now in minimal maintenance mode after 10 years as a 'work in progress', based on a
manuscript prepared for a lecture at the BLUG (see <A
HREF="http://www.blug.linux.no/"
TARGET="_top"
>http://www.blug.linux.no/</A
>) meeting of
January 27th, 2005. Along the way it has spawned several conference tutorials as well as <A
HREF="http://www.nostarch.com/pf3"
TARGET="_top"
>The Book of PF</A
> (third edition, No Starch Press 2014), which expands on all topics mentioned in this document presents several topics that are only hinted at here. While this document has been a useful starting point for number of people, I <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>strongly</I
></SPAN
> suggest that you get the book.</P
><P
>I'm interested in comments of all kinds, and you may if you wish add web
or other references to html or pdf versions of the manuscript.  If you do, I would
like, but can not require, you to send me an email message that you've done it. 
For communication regarding this document please use the address <CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:peter@bsdly.net"
>peter@bsdly.net</A
>&#62;</CODE
> and preferably a recognizable subject line; <SAMP
CLASS="COMPUTEROUTPUT"
>$ </SAMP
><KBD
CLASS="USERINPUT"
>whois bsdly.net</KBD
> provides full contact information.</P
><P
></P
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#PREFACE"
>Before we start</A
></DT
><DT
><A
HREF="#INTRO"
>PF?</A
></DT
><DT
><A
HREF="#CONCEPTS"
>Packet filter? Firewall?</A
></DT
><DT
><A
HREF="#NAT"
>NAT?</A
></DT
><DT
><A
HREF="#PFTODAY"
>PF today</A
></DT
><DT
><A
HREF="#BSDVSLINUX"
>BSD vs Linux - Configuration</A
></DT
><DT
><A
HREF="#SIMPLESTCONFIG"
>Simplest possible setup (OpenBSD)</A
></DT
><DT
><A
HREF="#SIMPLESTFREEBSD"
>Simplest possible setup (FreeBSD)</A
></DT
><DT
><A
HREF="#NETBSDBASICS"
>Simplest possible setup (NetBSD)</A
></DT
><DT
><A
HREF="#MINIMAL-RULESET"
>First rule set - single machine</A
></DT
><DT
><A
HREF="#STRICTER"
>Slightly stricter</A
></DT
><DT
><A
HREF="#PFCTLSTATS"
>Statistics from <SPAN
CLASS="APPLICATION"
>pfctl</SPAN
></A
></DT
><DT
><A
HREF="#BASICGW"
>A simple gateway, NAT if you need it</A
></DT
><DD
><DL
><DT
><A
HREF="#GWPITFALLS"
>Gateways and the pitfalls of in, out and on</A
></DT
><DT
><A
HREF="#WHATSYOURLOCALNET"
>What is your local network, anyway?</A
></DT
><DT
><A
HREF="#GWSIMPLESETUP"
>Setting up</A
></DT
></DL
></DD
><DT
><A
HREF="#FTPPROBLEM"
>That sad old FTP thing</A
></DT
><DD
><DL
><DT
><A
HREF="#FRESH-FTP-PROXY"
>If We Have To: ftp-proxy With Divert or Redirection</A
></DT
><DT
><A
HREF="#HISTORICAL-DEPRECATED"
>Historical FTP proxies: do not use</A
></DT
><DD
><DL
><DT
><A
HREF="#FTP-PROXY"
>Ancient FTP through NAT: <SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
></A
></DT
><DT
><A
HREF="#FTPSESAME"
>Ancient: FTP, PF and routable addresses: <SPAN
CLASS="APPLICATION"
>ftpsesame</SPAN
>, <SPAN
CLASS="APPLICATION"
>pftpx</SPAN
> and <SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
>!</A
></DT
><DT
><A
HREF="#NEWFTPPROXY"
><SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
>, slightly new style</A
></DT
></DL
></DD
></DL
></DD
><DT
><A
HREF="#TROUBLESHOOT"
>Making your network troubleshooting friendly</A
></DT
><DD
><DL
><DT
><A
HREF="#DOWEPASS"
>Then, do we let it all through?</A
></DT
><DT
><A
HREF="#ICMPSTOPATGW"
>The easy way out: The buck stops here</A
></DT
><DT
><A
HREF="#LETPINGTHRU"
>Letting <SPAN
CLASS="APPLICATION"
>ping</SPAN
> through</A
></DT
><DT
><A
HREF="#HELPTRACEROUTE"
>Helping <SPAN
CLASS="APPLICATION"
>traceroute</SPAN
></A
></DT
><DT
><A
HREF="#PATHMTUDISC"
>Path MTU discovery</A
></DT
></DL
></DD
><DT
><A
HREF="#HYGIENE"
>Network hygiene: Blocking, scrubbing and so on</A
></DT
><DD
><DL
><DT
><A
HREF="#BLOCKPOLICY"
><KBD
CLASS="USERINPUT"
>block-policy</KBD
></A
></DT
><DT
><A
HREF="#SCRUB"
><KBD
CLASS="USERINPUT"
>scrub</KBD
></A
></DT
><DT
><A
HREF="#ANTISPOOF"
><KBD
CLASS="USERINPUT"
>antispoof</KBD
></A
></DT
><DT
><A
HREF="#UNROUTEABLES"
>Handling non-routable addresses from elsewhere</A
></DT
></DL
></DD
><DT
><A
HREF="#RDR2SERVERS"
>A web server and a mail server on the inside</A
></DT
><DD
><DL
><DT
><A
HREF="#RDRFROMINSIDE"
>Taking care of your own - the inside</A
></DT
></DL
></DD
><DT
><A
HREF="#TABLES"
>Tables make your life easier</A
></DT
><DT
><A
HREF="#LOGGING"
>Logging</A
></DT
><DD
><DL
><DT
><A
HREF="#TCPDUMPEX"
>Taking a peek with <SPAN
CLASS="APPLICATION"
>tcpdump</SPAN
></A
></DT
><DT
><A
HREF="#OTHERLOGTOOLS"
>Other log tools you may want to look into</A
></DT
><DT
><A
HREF="#LOGSIZES"
>But there are limits (an anecdote)</A
></DT
></DL
></DD
><DT
><A
HREF="#SYSTAT-STATES"
>Keeping an eye on things with systat</A
></DT
><DT
><A
HREF="#PFTOP"
>Keeping an eye on things with pftop</A
></DT
><DT
><A
HREF="#BRIDGE"
>Invisible gateway - bridge</A
></DT
><DT
><A
HREF="#ALTQINTRO"
>Directing traffic with ALTQ</A
></DT
><DD
><DL
><DT
><A
HREF="#ALTQACKPRI"
>ALTQ - prioritizing by traffic type</A
></DT
><DD
><DL
><DT
><A
HREF="#ALTQACKPRI.TOS"
>So why does this work?</A
></DT
><DT
><A
HREF="#MATCHQUEUEASSIGN"
>Using a match Rule for Queue Assignment</A
></DT
></DL
></DD
><DT
><A
HREF="#ALTQBYPCT"
>ALTQ - allocation by percentage</A
></DT
><DT
><A
HREF="#ALTQSMTP"
>ALTQ - handling unwanted traffic</A
></DT
></DL
></DD
><DT
><A
HREF="#CARP"
>CARP and pfsync</A
></DT
><DT
><A
HREF="#WIRELESS.SIMPLE"
>Wireless networks made simple</A
></DT
><DD
><DL
><DT
><A
HREF="#WIFIBACKGROUND"
>A little IEEE 802.11 background</A
></DT
><DD
><DL
><DT
><A
HREF="#WEP"
>WEP (Wired Equivalent Privacy)</A
></DT
><DT
><A
HREF="#WPA"
>WPA (WiFi Protected Access)</A
></DT
></DL
></DD
><DT
><A
HREF="#WIRELESS.SIMPLE.SETUP"
>Setting up a simple wireless network</A
></DT
></DL
></DD
><DT
><A
HREF="#VEGARD.AUTHPF"
>An open, yet tightly guarded wireless network with <SPAN
CLASS="APPLICATION"
>authpf</SPAN
></A
></DT
><DT
><A
HREF="#BRUTEFORCE"
>Turning away the brutes</A
></DT
><DD
><DL
><DT
><A
HREF="#EXPIRE"
>expiring table entries with <SPAN
CLASS="APPLICATION"
>pfctl</SPAN
></A
></DT
><DT
><A
HREF="#EXPIRETABLE"
>Using <SPAN
CLASS="APPLICATION"
>expiretable</SPAN
> to tidy your tables</A
></DT
></DL
></DD
><DT
><A
HREF="#SPAMD"
>Giving spammers a hard time</A
></DT
><DD
><DL
><DT
><A
HREF="#SPAMD.NOTALONE"
>Remember, you are not alone: blacklisting</A
></DT
><DT
><A
HREF="#SPAMD.TARANDGREY"
>List of black and grey, and the sticky tarpit</A
></DT
><DT
><A
HREF="#SPAMD.SETUP"
>Setting up <SPAN
CLASS="APPLICATION"
>spamd</SPAN
></A
></DT
><DT
><A
HREF="#SPAMD.EXPERIENCE"
>Some early highlights of our <SPAN
CLASS="APPLICATION"
>spamd</SPAN
> experience</A
></DT
><DT
><A
HREF="#SPAMD.GREYTRAPPING"
>Beating'em up some more: <SPAN
CLASS="APPLICATION"
>spamdb</SPAN
> and greytrapping</A
></DT
><DD
><DL
><DT
><A
HREF="#SPAMD.GREYTRAPPING.WHY"
>Enter greytrapping</A
></DT
><DT
><A
HREF="#SPAMD.GREYTRAPPING.HOW"
>Your own traplist</A
></DT
><DT
><A
HREF="#SPAMD.GREYTRAPPING.MISC"
>Deleting, handling trapped entries</A
></DT
><DT
><A
HREF="#DOWNSIDE-WHITELISTING"
>The downside: some people really do not get it</A
></DT
></DL
></DD
><DT
><A
HREF="#SPAMD.CONCLUSION"
>Conclusions from our <SPAN
CLASS="APPLICATION"
>spamd</SPAN
> experience</A
></DT
></DL
></DD
><DT
><A
HREF="#PFHAIKU"
>PF - Haiku</A
></DT
><DT
><A
HREF="#REFERENCES"
>References</A
></DT
><DT
><A
HREF="#WEBHOME"
>Where to find the tutorial on the web</A
></DT
><DD
><DL
><DT
><A
HREF="#SUPPPORTTHEPROJECT"
>If you enjoyed this: Buy OpenBSD CDs and other items, donate!</A
></DT
></DL
></DD
></DL
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="PREFACE"
></A
>Before we start</H1
><P
>This lecture<A
NAME="AEN302"
HREF="#FTN.AEN302"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
>
 will be about firewalls and related functions, starting
from <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>a little</I
></SPAN
> theory along with a number of
examples of filtering and other network traffic directing. As in any
number of other endeavors, the things I discuss can be done
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>in more than one way</I
></SPAN
>.  </P
><DIV
CLASS="NOTE"
><A
NAME="BOOKOFPF-FIRST"
></A
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./note.jpg"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>More information: The Book of PF, training, consulting</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Most of the topics we touch on here is covered in more detail in <A
HREF="http://www.nostarch.com/pf3"
TARGET="_top"
>The Book of
PF</A
>, which was written by the same author and published by No Starch Press at
the end of 2007, with a revised and updated <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>second edition</I
></SPAN
> published in November 2010, followed <A
HREF="http://bsdly.blogspot.no/2014/10/the-book-of-pf-3rd-edition-is-here.html"
TARGET="_top"
>in October 2014</A
> by the now-current third edition.  The book is an expanded and extensively rewritten followup to this tutorial, and covers a range of advanced topics in
addition to those covered here.</P
><P
>This document is now in minimal maintenance mode after 10 years as a 'work in progress', based on a
manuscript prepared for a lecture at the BLUG (see <A
HREF="http://www.blug.linux.no/"
TARGET="_top"
>http://www.blug.linux.no/</A
>) meeting of
January 27th, 2005. Along the way it has spawned several conference tutorials as well as <A
HREF="http://www.nostarch.com/pf3"
TARGET="_top"
>The Book of PF</A
> (third edition, No Starch Press 2014), which expands on all topics mentioned in this document presents several topics that are only hinted at here. While this document has been a useful starting point for number of people, I <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>strongly</I
></SPAN
> suggest that you get the book.</P
><P
>This tutorial is in minimal-maintainence mode (after 10 years as a work in progress), in that I'll occasionally make an effort to keep the information in it up to date, but it will not expand in scope. For more in-depth information or topics not covered here, check <A
HREF="http://www.nostarch.com/pf3"
TARGET="_top"
>the book</A
>, the <A
HREF="http://home.nuug.no/~peter/pf/newest/"
TARGET="_top"
>slides</A
> 
matching the latest tutorial session, 
the <A
HREF="http://www.openbsd.org/faq/pf/"
TARGET="_top"
>PF User Guide</A
> (also known as <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>The PF FAQ</I
></SPAN
>) or the relevant <KBD
CLASS="USERINPUT"
>man</KBD
> pages. </P
><P
>If you're aiming to use PF on FreeBSD, it's worth looking up the FreeBSD Handbook's <A
HREF="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/firewalls-pf.html"
TARGET="_top"
>PF Firewall</A
> chapter, which is based on an earlier version of this tutorial with various edits by FreeBSD documentation maintainers.</P
><P
>If you need PF related consulting or training, please contact me for further details.  You may want to read my <A
HREF="http://www.bsdly.net/~peter/rentageek.html"
TARGET="_top"
>Rent-a-geek</A
> writeup too. </P
></TD
></TR
></TABLE
></DIV
><P
>Under any circumstances I
will urge you to interrupt me when you need to. That is, if you will
permit me to use what I learn from your comments later, either in
revised versions of this lecture or in practice at a later time.  But first,</P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./warning.jpg"
HSPACE="5"
ALT="Warning"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>This is not a HOWTO</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This document is not intended as a pre-cooked recipe for cutting and pasting.</P
><P
>Just to hammer this in, please repeat after me </P
><PRE
CLASS="SCREEN"
>The Pledge of the Network Admin

This is my network. 

It is mine 
or technically my employer's, 
it is my responsibility 
and I care for it with all my heart

there are many other networks a lot like mine,

but none are just like it.

I solemnly swear 

that I will not mindlessly paste from HOWTOs.</PRE
><P
>The point is, while the rules and configurations I show you do work, I have tested them
and they are in some way related to what has been put into production,
they may very well be overly simplistic and are almost certain to 
be at least a little off and possibly quite wrong for <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>your</I
></SPAN
> network.</P
><P
>Please keep in mind that this document is intended to show you a few useful 
things and inspire you to achieve good things.  </P
><P
>Please strive to understand your network and what you need to do to make it better. </P
><P
>Please do not paste blindly from this document or any other.</P
></TD
></TR
></TABLE
></DIV
><P
>Now, with that out of the way, we can go on to the meat of the matter.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="INTRO"
></A
>PF?</H1
><P
>What, then is PF?  Let us start by looking briefly at the project's
history to put things in their proper context.</P
><P
>OpenBSD's Packet Filter subsystem, which most people refer to simply
by using the abbreviated form 'PF', was originally written in an
effort of extremely rapid development during the northern hemisphere
summer and autumn months of 2001 by Daniel Hartmeier and a number of
OpenBSD developers, and was launched as a default part of the OpenBSD
3.0 base system in December of 2001.</P
><P
>The need for a new firewalling software subsystem for OpenBSD arose
when Darren Reed announced to the world that IPFilter, which at that
point had been rather intimately integrated in OpenBSD, was not after
all BSD licensed.  In fact quite to the contrary.  The license itself
was almost a word by word copy of the BSD license, omitting only the
right to make changes to the code and distribute the result.  The
OpenBSD version of IPFilter contained quite a number of changes and
customizations, which it turned out were not allowed according to the
license. IPFilter was removed from the OpenBSD source tree on May
29th, 2001, and for a few weeks OpenBSD-current did not contain any
firewalling software.</P
><P
>Fortunately, in Switzerland Daniel Hartmeier was already doing some
limited experiments involving kernel hacking in the networking code. </P
><P
>His starting point was hooking a small function of his own into the
networking stack, making packets pass through it, and after a while he
had started thinking about filtering.  Then the license crisis happened.</P
><P
>IPFilter was pruned from the source tree on May 29th. The first commit
of the PF code happened Sunday, June 24 2001 at 19:48:58 UTC.<A
NAME="AEN352"
HREF="#FTN.AEN352"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
></P
><P
>A few months of rather intense activity followed, and the version of
PF that was released with OpenBSD 3.0 contained a rather complete
implementation of packet filtering, including network address
translation.</P
><P
>From the looks of it, Daniel Hartmeier and the other PF developers
made good use of their experience with the IPFilter code. Under any
circumstances Daniel presented a USENIX 2002 paper with performance
tests which show that the OpenBSD 3.1 PF performed equally well as or
better under stress than IPFilter on the same platform or iptables on
Linux.</P
><P
>In addition, some tests were run on the original PF from OpenBSD 3.0.
These tests showed mainly that the code had gained in efficiency from
version 3.0 to version 3.1. The article which provides the details
is available from Daniel Hartmeier's web, see <A
HREF="http://www.benzedrine.ch/pf-paper.html"
TARGET="_top"
><I
CLASS="CITETITLE"
>http://www.benzedrine.ch/pf-paper.html</I
></A
>.</P
><P
>I have not seen comparable tests performed recently, but in my own
experience and that of others, the PF filtering overhead is pretty
much negligible.  As one data point, the machine which gateways
between one of the networks where I've done a bit of work and the
world is a Pentium III 450MHz with 384MB of RAM. When I've remembered
to check, I've never seen the machine at less than 96 percent 'idle'
according to <SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/top"
TARGET="_top"
>top</A
></SPAN
>.</P
><P
>It is however worth noting that various optimisations have been
introduced to OpenBSD's PF code during recent releases (mainly by the
current main PF developers Henning Brauer and Ryan McBride with
contributions from others), making each release from 4.4 through 5.6
perform better than its predecessors.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CONCEPTS"
></A
>Packet filter? Firewall? </H1
><P
>By now I have already used some terms and concepts before I've
bothered to explain them, and I'll correct that oversight shortly.  PF
is a <I
CLASS="FIRSTTERM"
>packet filter</I
>, that is, code which
inspects network packets at the protocol and port level, and decides
what to do with them.  In PF's case this code for the most part
operates in kernel space, inside the network code.</P
><P
>PF operates in a world which consists of packets, protocols,
connections and ports.</P
><P
>Based on where a packet is coming from or where it's going, which
protocol, connection or port it is designated for, PF is able to
determine where to lead the packet, or decide if it is to be let
through at all.</P
><P
>It's equally possible to direct network traffic based on packet
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>contents</I
></SPAN
>, usually referred to as application
level filtering, but this is not the kind of thing PF does. We will
come back later to some cases where PF will hand off these kinds of
tasks to other software, but first let us deal with some basics.</P
><P
>We've already mentioned the firewall concept. One important feature of
PF and similar software, perhaps the most important feature, is that it
is able to identify and block traffic which you do not want to let
into your local network or let out to the world outside. At some point
the term '<I
CLASS="FIRSTTERM"
>firewall</I
>' was coined.</P
><P
>While blocking &quot;bad&quot; traffic and denying access can be
quite important, I tend to emphasize the somewhat wider and more
general perspective that the packet filter is a very flexible tool
which is extremely useful when you want to <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>take
control</I
></SPAN
> of what happens in your network.</P
><P
>Taking control means you get to make informed decisions, and that, in
my opinion, is when the fun part of being a network administrator
starts.  And you should be forewarned, staying in control is a
recurring theme in this session.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="NAT"
></A
>NAT?</H1
><P
>One other thing we will be talking about quite a lot are 'inner' and
'outer' addresses, 'routable' and 'non-routable' addresses.  This is,
at the heart of things, not directly related to firewalls or packet
filtering, but due to the way the world works today, we will need to
touch on it.</P
><P
>It all comes from the time in the early 1990s when somebody started
calculating the number of computers which would be connected to the
Internet if the commercialization continued and the great unwashed
masses of consumers were to connect at the same time.</P
><P
>At the time the Internet protocols were formulated, computers were
usually big, expensive things which would normally serve a large
number of simultaneous users, each at their own more or less dumb
terminal. Under any circumstances, the only ones allowed to connect
were universities and a number of companies with Pentagon contracts.
Essentially 32 bit addresses of 4 octets would go an extremely long
way.  It would accommodate literally millions of machines, even.</P
><P
>Then Internet commercialization happened, and all of a sudden there
were actually millions of small, inexpensive machines wanting to
connect at the same time.  This kind of development showed every sign
of continuing and even accelerating.  This meant that the smart people
who had made the net work, needed to do another few pieces of
work. They did a few things more or less at the same time. For one, they
started working on a solution based on a larger address space - this has
been dubbed IP version 6, or IPv6 for short - which uses 128 bit addresses.
This has been designated as the long term solution. I thought I'd mention
at this point that IPv6 support is built into OpenBSD by default, and
PF has as far as I know always contained IPv6 support<A
NAME="AEN384"
HREF="#FTN.AEN384"
><SPAN
CLASS="footnote"
>[3]</SPAN
></A
>.  If you need to filter on traffic belonging to both <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>address families</I
></SPAN
>, you differentiate by designating <KBD
CLASS="USERINPUT"
>inet</KBD
> for rules that apply to IPv4 traffic and <KBD
CLASS="USERINPUT"
>inet6</KBD
> for rules that apply to IPv6 traffic.  The examples in this document were originally written for an IPv4-only setting, but most of the material here will apply equally to both address families.</P
><P
>In addition, some sort of temporary solution was needed. Making the
world move to addresses four times the size would take considerable
time. The process is as far as we can see still pretty much in an
early stage. They found a temporary solution, which consists of two
parts. One part was a mechanism to offer the rest of the world 'white
lies' by letting the network gateways rewrite packet addresses, the
other was offered by designating some address ranges which had not
been assigned earlier for use only in networks which would not
communicate directly with the Internet at large. This would mean that
several different machines at separate locations could have the same
local IP address. But this would not matter because the address would
be translated before the traffic was let out to the net at large.</P
><P
>If traffic with such "non routable" addresses were to hit the Internet
at large, routers seeing the traffic would have a valid reason to
refuse the packets to pass any further.</P
><P
>This is what is called "Network Address Translation", sometimes referred to
as "IP masquerade" or similar. The two RFCs which define the whats and hows of 
this are dated 1994 and 1996 respectively
<A
NAME="AEN392"
HREF="#FTN.AEN392"
><SPAN
CLASS="footnote"
>[4]</SPAN
></A
>.</P
><P
>There may be a number of reasons to use the so called "RFC 1918 addresses",
but traditionally and historically the main reason has been that official
addresses are either not available or practical.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="PFTODAY"
></A
>PF today</H1
><P
>At this point, we have covered a bit of background. Some years have passed 
since 2001, and PF in its present OpenBSD 6.1 form is a packet filter which
is capable of doing quite a few things, if you want it to.</P
><P
>For one thing, PF classifies packets based on protocol, port, packet
type, source or destination address. With a reasonable degree of
certainty it is also able to classify packets based on source
operating system.</P
><P
>And even if NAT is not a necessary part of a packet filter, for
practical reasons it's nice that the address rewriting logic is
handled somewhere nearby. Consequently, PF contains NAT logic as well.</P
><P
>PF is able - based on various combinations of protocol, port and other
data - to direct traffic to other destinations than those designated
by the sender, for example to a different machine or for further
processing by a program such as a daemon listening at a port, locally
or on a different machine.</P
><P
>Before PF was written, OpenBSD already contained the <I
CLASS="FIRSTTERM"
>ALTQ</I
> code to
handle load balancing and traffic shaping. After a while, altq was
integrated with PF. Mainly for practical reasons.<A
NAME="AEN404"
HREF="#FTN.AEN404"
><SPAN
CLASS="footnote"
>[5]</SPAN
></A
></P
><P
>As a result of this, all those features are available to you via one
single, essentially human readable configuration file, which is
usually called <TT
CLASS="FILENAME"
>pf.conf</TT
>, stored in the
<TT
CLASS="FILENAME"
>/etc/</TT
> directory.</P
><P
>This is now available as a part of the base system on OpenBSD, on
FreeBSD where PF from version 5.4 is one of three firewalling systems
to be loaded at will, and in NetBSD and DragonFlyBSD. The last two
operating systems I have not had the resources to play much with
myself.  Something about having both hardware and time available at
the same time.  Anyway all indications are that only very minor
details vary between these systems as far as PF is involved, except that the PF versions in the other systems tend to trail the OpenBSD PF versions by a few revisions, mostly due to variations in developent and release cycles.  With a <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>flag day</I
></SPAN
> release like OpenBSD 4.7, the differences between operating systems can be rather significant until all systems have caught up.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="BSDVSLINUX"
></A
>BSD vs Linux - Configuration</H1
><P
>I assume that some of those who read this document are more familiar
with configuring Linux or other systems than with BSD, so I'll briefly
mention a few points about BSD system and network configuration.</P
><P
>BSD network interfaces are not labeled <TT
CLASS="FILENAME"
>eth0</TT
>,
<TT
CLASS="FILENAME"
>eth1</TT
> and so on.  The interfaces are assigned
names which equal the driver name plus a sequence number, making 3Com
cards using the <TT
CLASS="FILENAME"
>xl</TT
> driver appear as
<TT
CLASS="FILENAME"
>xl0</TT
>, <TT
CLASS="FILENAME"
>xl1</TT
>, and so on, while
Some Intel cards are likely to end up as <TT
CLASS="FILENAME"
>em0</TT
>,
<TT
CLASS="FILENAME"
>em1</TT
>, others are supported by the
<TT
CLASS="FILENAME"
>fxp</TT
> driver, and so on.  There may even be slight
variations in which cards are supported in which drivers across the
BSDs.<A
NAME="AEN425"
HREF="#FTN.AEN425"
><SPAN
CLASS="footnote"
>[6]</SPAN
></A
></P
><P
>For boot-time configuration, the BSDs are generally organized to read
the configuration from <A
HREF="http://man.openbsd.org/rc.conf"
TARGET="_top"
>/etc/rc.conf</A
>, which is
read by the <A
HREF="http://man.openbsd.org/rc"
TARGET="_top"
>/etc/rc</A
> script at startup.  OpenBSD
recommends using <TT
CLASS="FILENAME"
>/etc/rc.conf.local</TT
> for local
customizations, since <TT
CLASS="FILENAME"
>rc.conf</TT
> contains the
default values, while FreeBSD uses
<TT
CLASS="FILENAME"
>/etc/defaults/rc.conf</TT
> to store the default
settings, making <TT
CLASS="FILENAME"
>/etc/rc.conf</TT
> the correct place
to make changes.</P
><P
>PF is configured by editing the <A
HREF="http://man.openbsd.org/pf.conf"
TARGET="_top"
>/etc/pf.conf</A
> file and
by using the <SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/pfctl"
TARGET="_top"
>pfctl</A
></SPAN
> command line tool. The 
<SPAN
CLASS="APPLICATION"
>pfctl</SPAN
> application has a <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>large</I
></SPAN
> 
number of options. We will take a closer look at some of them today.</P
><P
>In case you are wondering, there are web interfaces available for
admin tasks (such as the FreeBSD based <A
HREF="http://pfsense.org/"
TARGET="_top"
>pfSense</A
> and the OpenBSD based and supposedly portable <A
HREF="http://pfpro.sourceforge.net/"
TARGET="_top"
>PfPro</A
>), but they are not parts of the base system.  The PF
developers are not hostile to these things, but rather have not seen
any graphical interface to PF configuration which without a doubt is
preferable to <A
HREF="http://man.openbsd.org/pf.conf"
TARGET="_top"
>pf.conf</A
> in a text editor, backed up
with <SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/pfctl"
TARGET="_top"
>pfctl</A
></SPAN
> invocations and a few unix
tricks.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="SIMPLESTCONFIG"
></A
>Simplest possible setup (OpenBSD)</H1
><P
>This brings us, finally, to the practical point of actually configuring
PF in the simplest possible setup. We'll deal with a single machine
which will communicate with a network which may very well be the Internet.</P
><P
>In order to start PF, as previously mentioned, you need to tell the
<SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/rc"
TARGET="_top"
>rc</A
></SPAN
> system that you want the service to
start.  That is, in OpenBSD 4.6 and newer, you don't have to do this
yourself: PF with a very minimalistic rule set is enabled by default.
In OpenBSD versions earlier than 4.6, you enable PF by editing or
creating the file <TT
CLASS="FILENAME"
>/etc/rc.conf.local</TT
>, and adding
the magical line</P
><PRE
CLASS="PROGRAMLISTING"
>pf=YES                # enable PF</PRE
><P
>quite simply.  In addition, you may if you like specify the file where
PF will find its rules. </P
><PRE
CLASS="PROGRAMLISTING"
>pf_rules=/etc/pf.conf # specify which file contains your rules</PRE
><P
>The default value is the one given here, <TT
CLASS="FILENAME"
>/etc/pf.conf</TT
>.  
At the next startup, PF will be enabled.  You can verify this by
looking for the message <SAMP
CLASS="COMPUTEROUTPUT"
>PF enabled</SAMP
> on
the console.  The <TT
CLASS="FILENAME"
>/etc/pf.conf</TT
> which comes out of
a normal install of OpenBSD or NetBSD contains a number of
useful suggestions, but they're all commented out. On FreeBSD, you will need to create a <TT
CLASS="FILENAME"
>/etc/pf.conf</TT
> file yourself.</P
><P
>Then again, you really do not need to restart your machine in order to
enable PF.  You can do this just as easily by using
<SPAN
CLASS="APPLICATION"
>pfctl</SPAN
>.  We really do not want to reboot for
no good reason, so we type the command</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>doas pfctl -ef /etc/pf.conf</KBD
></PRE
><P
>which enables PF and loads your rule set.<A
NAME="AEN469"
HREF="#FTN.AEN469"
><SPAN
CLASS="footnote"
>[7]</SPAN
></A
><A
NAME="AEN475"
HREF="#FTN.AEN475"
><SPAN
CLASS="footnote"
>[8]</SPAN
></A
>. At this point
we do not have a rule set (unless you are running with the OpenBSD
default), which means that PF does not actually do anything, just
passes packets.</P
><P
>It is probably worth noting that if you reboot your machine at this
point, the rc script on OpenBSD at least will enable a default rule
set, which is in fact loaded <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>before</I
></SPAN
> any of the
network interfaces are enabled. </P
><P
>This default rule set is designed as a safety measure in case your
gateway boots with an invalid configuration.  It lets you log in and
clean up whichever syntax error caused your rule set not to load. The
default rule set allows a basic set of services: <SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/ssh"
TARGET="_top"
>ssh</A
></SPAN
> from anywhere,
basic name resolution and NFS mounts.  </P
><P
>Some early versions of PF ports elsewhere appear to have neglected to
bring the default rules with them.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="SIMPLESTFREEBSD"
></A
>Simplest possible setup (FreeBSD)</H1
><P
>On FreeBSD it could seem that you need a little more magic in your
<TT
CLASS="FILENAME"
>/etc/rc.conf</TT
>, specifically according to the
FreeBSD Handbook<A
NAME="AEN489"
HREF="#FTN.AEN489"
><SPAN
CLASS="footnote"
>[9]</SPAN
></A
></P
><PRE
CLASS="PROGRAMLISTING"
>pf_enable="YES"                 # Enable PF (load module if required)
pf_rules="/etc/pf.conf"         # rules definition file for PF
pf_flags=""                     # additional flags for pfctl startup
pflog_enable="YES"              # start pflogd(8)
pflog_logfile="/var/log/pflog"  # where pflogd should store the logfile
pflog_flags=""                  # additional flags for pflogd startup</PRE
><P
>Fortunately almost all of these are already present as the default
settings in your <TT
CLASS="FILENAME"
>/etc/defaults/rc.conf</TT
>, and only </P
><PRE
CLASS="PROGRAMLISTING"
>pf_enable="YES"                 # Enable PF (load module if required)
pflog_enable="YES"              # start pflogd(8)</PRE
><P
>are in fact needed as additions to your
<TT
CLASS="FILENAME"
>/etc/rc.conf</TT
> in order to enable PF.</P
><P
>On FreeBSD, PF by default is compiled as a kernel loadable module.
This means that you should be able to get started<A
NAME="AEN499"
HREF="#FTN.AEN499"
><SPAN
CLASS="footnote"
>[10]</SPAN
></A
> right after you have
added those two lines to your configuration with
<SAMP
CLASS="COMPUTEROUTPUT"
>$</SAMP
>
<KBD
CLASS="USERINPUT"
><SPAN
CLASS="APPLICATION"
>sudo</SPAN
>
<SPAN
CLASS="APPLICATION"
>kldload</SPAN
> pf</KBD
>, followed by
<SAMP
CLASS="COMPUTEROUTPUT"
>$</SAMP
>
<KBD
CLASS="USERINPUT"
><SPAN
CLASS="APPLICATION"
>sudo</SPAN
>
<SPAN
CLASS="APPLICATION"
>pfctl</SPAN
> -e</KBD
> to enable PF.
Assuming you have put these lines in your
<TT
CLASS="FILENAME"
>/etc/rc.conf</TT
>, you can use the PF
<SPAN
CLASS="APPLICATION"
>rc</SPAN
> script to enable or disable PF:</P
><P
><SAMP
CLASS="COMPUTEROUTPUT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
><SPAN
CLASS="APPLICATION"
>sudo</SPAN
> <SPAN
CLASS="APPLICATION"
>/etc/rc.d/pf</SPAN
> start</KBD
></P
><P
>to enable PF, or </P
><P
><SAMP
CLASS="COMPUTEROUTPUT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
><SPAN
CLASS="APPLICATION"
>sudo</SPAN
> <SPAN
CLASS="APPLICATION"
>/etc/rc.d/pf</SPAN
> stop</KBD
></P
><P
>to disable the packet filter. The <TT
CLASS="FILENAME"
>pf</TT
> rcNG script
supports a few other operations as well.  However it is still worth
noting that at this point we do not have a rule set, which means that
PF does not actually do anything.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="NETBSDBASICS"
></A
>Simplest possible setup (NetBSD)</H1
><P
>On NetBSD 2.0 and newer PF is available as a loadable kernel module, installed
via packages as <TT
CLASS="FILENAME"
>pkgsrc/security/pflkm</TT
> or compiled into a
static kernel configuration. In NetBSD 3.0 onwards, PF is part of the base system.</P
><P
>If you want to enable PF in your kernel configuration (rather than loading the
kernel module), you add these lines to your kernel configuration:</P
><PRE
CLASS="PROGRAMLISTING"
>pseudo-device  pf		# PF packet filter
pseudo-device  pflog		# PF log interface</PRE
><P
>In <TT
CLASS="FILENAME"
>/etc/rc.conf</TT
> you need the lines</P
><PRE
CLASS="PROGRAMLISTING"
>lkm="YES" # do load kernel modules
pf=YES 
pflogd=YES</PRE
><P
>to enable loadable kernel modules, PF and the PF log interface, respectively.</P
><P
>If you installed the module, you load it with <SAMP
CLASS="COMPUTEROUTPUT"
>NetBSD$</SAMP
> <KBD
CLASS="USERINPUT"
><SPAN
CLASS="APPLICATION"
>sudo</SPAN
> <SPAN
CLASS="APPLICATION"
>modload</SPAN
> /usr/lkm/pf.o</KBD
>, followed by 
<SAMP
CLASS="COMPUTEROUTPUT"
>NetBSD$</SAMP
> <KBD
CLASS="USERINPUT"
><SPAN
CLASS="APPLICATION"
>sudo</SPAN
> <SPAN
CLASS="APPLICATION"
>pfctl</SPAN
> -e</KBD
> to enable PF. Alternatively, you can run the rc scripts, <SAMP
CLASS="COMPUTEROUTPUT"
>NetBSD$</SAMP
> <KBD
CLASS="USERINPUT"
><SPAN
CLASS="APPLICATION"
>sudo</SPAN
> /etc/rc.d/pf start</KBD
> to enable PF and <SAMP
CLASS="COMPUTEROUTPUT"
>NetBSD$</SAMP
> <KBD
CLASS="USERINPUT"
><SPAN
CLASS="APPLICATION"
>sudo</SPAN
> /etc/rc.d/pflogd start</KBD
> to enable the logging.</P
><P
>To load the module automatically at startup, add the following line to <TT
CLASS="FILENAME"
>/etc/lkm.conf</TT
>:</P
><PRE
CLASS="PROGRAMLISTING"
>/usr/lkm/pf.o - - - - AFTERMOUNT</PRE
><P
>If it's still all correct at this point, you are ready to create your first PF rule set.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="MINIMAL-RULESET"
></A
>First rule set - single machine</H1
><P
>This is the simplest possible setup, for a single machine which will
not run any services, and which will talk to one network which may be
the Internet.  For now, we will use a <TT
CLASS="FILENAME"
>/etc/pf.conf</TT
>
which looks like this:</P
><PRE
CLASS="PROGRAMLISTING"
>block in all
pass out all keep state</PRE
><P
>that is, deny any incoming traffic, allow traffic we make ourselves,
and retain state information on our connections. Keeping state
information allows return traffic for all connections we have
initiated to pass back to us.  It is worth noting that from OpenBSD
4.1 onwards, the default for pass rules is to keep state
information<A
NAME="AEN563"
HREF="#FTN.AEN563"
><SPAN
CLASS="footnote"
>[11]</SPAN
></A
>, so the equivalent
rule set in the new OpenBSD 4.1 style is even simpler,</P
><PRE
CLASS="PROGRAMLISTING"
># minimal rule set, OpenBSD 4.1 and newer keeps state by default
block in all
pass out all</PRE
><P
>It goes pretty much without saying that passing all traffic generated
by a specific host implies a great deal of trust that the host in
question is, in fact, trustworthy.  This is something you do if and
only if this is a machine you know you can trust.  If you are ready to
use the rule set, you load it with</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
><SPAN
CLASS="APPLICATION"
>doas</SPAN
> <SPAN
CLASS="APPLICATION"
>pfctl</SPAN
> -ef <TT
CLASS="FILENAME"
>/etc/pf.conf</TT
></KBD
></PRE
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="STRICTER"
></A
>Slightly stricter</H1
><P
>For a slightly more structured and complete setup, we start by denying
everything and then allowing only those things we know that we
need<A
NAME="AEN577"
HREF="#FTN.AEN577"
><SPAN
CLASS="footnote"
>[12]</SPAN
></A
>.  This gives us
the opportunity to introduce two of the features which make PF such a
wonderful tool - lists and macros.</P
><P
>We'll make some changes to <TT
CLASS="FILENAME"
>/etc/pf.conf</TT
>, starting with</P
><PRE
CLASS="PROGRAMLISTING"
>block all</PRE
><P
>Then we back up a little. Macros need to be defined before use:</P
><PRE
CLASS="PROGRAMLISTING"
>tcp_services = "{ ssh, smtp, domain, www, pop3, auth, pop3s }"
udp_services = "{ domain }"</PRE
><P
>Now we've demonstrated several things at once - what macros look like,
we've shown that macros may be lists, and that PF understands rules using
port names equally well as it does port numbers.  The names are the ones
listed in <TT
CLASS="FILENAME"
>/etc/services</TT
>.  This gives us something
to put in our rules, which we edit slightly to look like this:</P
><PRE
CLASS="PROGRAMLISTING"
>block all
pass out proto tcp to port $tcp_services
pass proto udp to port $udp_services</PRE
><P
>Please remember to add <KBD
CLASS="USERINPUT"
>keep state</KBD
> to these rules if
your system has a PF version older than OpenBSD 4.1.</P
><P
>At this point some of us will point out that UDP is stateless, but PF
actually manages to maintain state information despite this.  When you
ask a name server about a domain name, it is reasonable to assume that
you probably want to receive the answer.  Retaining state information
about your UDP traffic achieves this.</P
><P
>Since we've made changes to our <TT
CLASS="FILENAME"
>pf.conf</TT
> file, we
load the new rules:</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
><SPAN
CLASS="APPLICATION"
>doas</SPAN
> <SPAN
CLASS="APPLICATION"
>pfctl</SPAN
> -f <TT
CLASS="FILENAME"
>/etc/pf.conf</TT
></KBD
></PRE
><P
>and the new rules apply.  If there are no syntax errors, 
<SPAN
CLASS="APPLICATION"
>pfctl</SPAN
> will not output any messages during the rule load.
The -v flag will produce more verbose <SPAN
CLASS="APPLICATION"
>pfctl</SPAN
> output.</P
><P
>If you have made extensive changes to your rule set, you may want to
check the rules before attempting to load them. The command to do this
is, <KBD
CLASS="USERINPUT"
><SPAN
CLASS="APPLICATION"
>pfctl</SPAN
> -nf
<TT
CLASS="FILENAME"
>/etc/pf.conf</TT
></KBD
>.  The
<KBD
CLASS="USERINPUT"
>-n</KBD
> option causes the rules to be interpreted
only without loading the rules.  This gives you an opportunity to
correct any errors.  Under any circumstances the last valid rule set
loaded will be in force until you either disable PF or load a new rule
set.</P
><P
>That is worth noting: When loading a new rule set, the last valid rule
set stays loaded until the new one is fully parsed and loaded, and PF
switches directly from one to the other. There is no intermediate
stage with no rules loaded or a mixture of the two rule sets.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="PFCTLSTATS"
></A
>Statistics from <SPAN
CLASS="APPLICATION"
>pfctl</SPAN
></H1
><P
>You may want to check that PF is actually running, and perhaps at the
same time look at some statistics.  The
<SPAN
CLASS="APPLICATION"
>pfctl</SPAN
> program offers a number of different
types of information if you use
<KBD
CLASS="USERINPUT"
><SPAN
CLASS="APPLICATION"
>pfctl</SPAN
> -s</KBD
>, adding the
type of information you want to display.  The following example is
taken from my home gateway while I was preparing an earlier version of
this lecture:</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>doas pfctl -s info</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>Status: Enabled for 17 days 00:24:58          Debug: Urgent

Interface Stats for ep0               IPv4             IPv6
  Bytes In                      9257508558                0
  Bytes Out                      551145119              352
  Packets In
    Passed                         7004355                0
    Blocked                          18975                0
  Packets Out
    Passed                         5222502                3
    Blocked                             65                2

State Table                          Total             Rate
  current entries                       15               
  searches                        19620603           13.3/s
  inserts                           173104            0.1/s
  removals                          173089            0.1/s
Counters
  match                             196723            0.1/s
  bad-offset                             0            0.0/s
  fragment                              22            0.0/s
  short                                  0            0.0/s
  normalize                              0            0.0/s
  memory                                 0            0.0/s
  bad-timestamp                          0            0.0/s
  congestion                             0            0.0/s
  ip-option                             28            0.0/s
  proto-cksum                          325            0.0/s
  state-mismatch                       983            0.0/s
  state-insert                           0            0.0/s
  state-limit                            0            0.0/s
  src-limit                             26            0.0/s
  synproxy                               0            0.0/s</SAMP
></PRE
><P
>The first line here indicates that PF is enabled and has been running
for for a little more than two weeks, which is equal to the time since I 
upgraded to what was then the latest snapshot.  
<KBD
CLASS="USERINPUT"
><SPAN
CLASS="APPLICATION"
>pfctl</SPAN
> -s all</KBD
> provides highly detailed information.  Try it and have a look, and while there, look into some of the other <SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/pfctl"
TARGET="_top"
>pfctl</A
></SPAN
> options.
<KBD
CLASS="USERINPUT"
>man 8 pfctl</KBD
> (or clicking the man page link in this paragraph) gives you full information.</P
><P
>At this point you have a single machine which should be able to
communicate reasonably well with other internet connected machines.
And while the rule set is very basic, it serves as an excellent
starting point for staying in control of your network.</P
><P
>This is a very basic rule set and a few things are still missing.  For
example, you probably want to let at least some ICMP and UDP traffic
through, if nothing else for your own troubleshooting needs.</P
><P
>And even though more modern and more secure options are available, you
will probably be required to handle the <SPAN
CLASS="APPLICATION"
>ftp</SPAN
> service. </P
><P
>We will return to these items shortly.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="BASICGW"
></A
>A simple gateway, NAT if you need it</H1
><P
>At this point we finally move on to the more realistic or at least
more common setups, where the machine with the packet filter or
firewall configured also acts as a gateway for at least one other
machine.</P
><P
>The other machines on the inside may of course also run firewall
software, but even if they do, it does not affect what we are
interested in here to any significant degree.</P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="GWPITFALLS"
>Gateways and the pitfalls of in, out and on</A
></H2
><P
>In the single machine setup, life is relatively simple.  Traffic you
create should either pass or not out to the rest of the world, and you
decide what you let in from elsewhere.</P
><P
>When you set up a gateway, your perspective changes.  You go from the
&quot;me versus the network out there&quot; setting to &quot;I am the
one who decides what to pass to or from all the networks I am
connected to&quot;.  The machine has several, or at least two, network
interfaces, each connected to a separate net.</P
><P
>Now it's very reasonable to think that if you want traffic to pass
from the network connected to <KBD
CLASS="USERINPUT"
>ep1</KBD
> to hosts on
the network connected to <KBD
CLASS="USERINPUT"
>ep0</KBD
>, you will need a
rule like this<A
NAME="AEN641"
HREF="#FTN.AEN641"
><SPAN
CLASS="footnote"
>[13]</SPAN
></A
>:</P
><PRE
CLASS="PROGRAMLISTING"
>pass in inet proto tcp on ep1 from ep1:network to ep0:network \
     port $ports </PRE
><P
></P
><P
>However, one of the most common and most complained-about mistakes in
firewall configuration is not realizing that the &quot;to&quot;
keyword does not in itself guarantee passage all the way there.  In
fact, the rule we just wrote only lets the traffic pass in to the
gateway itself, on the specific interface given in the rule.  </P
><P
>To let the packets get a bit further on and move into the next network
over, you would need a matching rule which says something like</P
><PRE
CLASS="PROGRAMLISTING"
>pass out inet proto tcp on ep0 from ep1:network to ep0:network \
     port $ports </PRE
><P
>These rules will work, but they will not necessarily achieve what you want.  </P
><P
>If there are good reasons why you need to have rules which are this
specific in your rule set, you know you need them and why.  By the end
of this tutorial you should be able to articulate with some precision,
in the context of your own network, just when such rules are needed.
However for the basic gateway configurations we'll be dealing with
here, what you really want to use is probably a rule which says</P
><PRE
CLASS="PROGRAMLISTING"
>pass inet proto tcp from ep1:network to any port $ports </PRE
><P
>to let your local net access the Internet and leave the detective work
to the <I
CLASS="FIRSTTERM"
>antispoof</I
> and
<I
CLASS="FIRSTTERM"
>scrub</I
> code.  They are both pretty good these
days, and we will get back to them later.  For now we just accept the
fact that for simple setups, interface bound rules with in/out rules
tend to add more clutter than they are worth to your rule sets.</P
><P
>For a busy network admin, a readable rule set is a safer rule set.</P
><P
>For the remainder of this tutorial, with some exceptions, we will keep
the rules as simple as possible for readability.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="WHATSYOURLOCALNET"
>What is your local network, anyway?</A
></H2
><P
>Above we introduced the <KBD
CLASS="USERINPUT"
>interface:network</KBD
>
notation.  That is a nice piece of shorthand, but you make your rule
set even more readable and maintainable by taking the macro use a tiny
bit further.</P
><P
>You could for example define a <KBD
CLASS="USERINPUT"
>$localnet</KBD
> macro,
initially defined as the network directly attached to your internal
interface (<KBD
CLASS="USERINPUT"
>ep1:network</KBD
> in the examples above).  </P
><P
>Alternatively, you could change the definition of
<KBD
CLASS="USERINPUT"
>$localnet</KBD
> to an <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>IP
address/netmask</I
></SPAN
> notation to denote a network, such as
<KBD
CLASS="USERINPUT"
>192.168.100.0/24</KBD
> for a subnet of private IPv4
addresses or <KBD
CLASS="USERINPUT"
>fec0:dead:beef::/64</KBD
> for an IPv6 range.</P
><P
>If your network requires it, you could even define your
<KBD
CLASS="USERINPUT"
>$localnet</KBD
> as a list of networks.  Whatever your
specific needs, a sensible <KBD
CLASS="USERINPUT"
>$localnet</KBD
> definition
and a typical pass rule of the type</P
><PRE
CLASS="PROGRAMLISTING"
>pass inet proto tcp from $localnet to port $ports keep state</PRE
><P
>could end up saving you a few headaches.  We will stick to that convention from here on.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="GWSIMPLESETUP"
>Setting up</A
></H2
><P
>We assume that the machine has acquired another network card or at any
rate you have set up a network connection from your local network, via
PPP or other means.  We will not consider the specific interface
configurations. </P
><P
>For the discussion and examples below, only the interface names will
differ between a PPP setup and an Ethernet one, and we will do our
best to get rid of the actual interface names as quickly as possible.</P
><P
>First, we need to turn on gatewaying in order to let the machine forward
the network traffic it receives on one interface to other networks via
a separate interface.  Initially we will do this on the command line with
<SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/pfctl"
TARGET="_top"
>sysctl</A
></SPAN
>, for traditional <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>IP version four</I
></SPAN
> </P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>#</SAMP
> <KBD
CLASS="USERINPUT"
>sysctl net.inet.ip.forwarding=1</KBD
></PRE
><P
>and if we need to forward <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>IP version six</I
></SPAN
> traffic, the command is</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>#</SAMP
> <KBD
CLASS="USERINPUT"
>sysctl net.inet6.ip6.forwarding=1</KBD
></PRE
><P
>In order for this to work once you reboot the computer at some time in the future,
you need to enter these settings into the relevant configuration files.</P
><P
>In OpenBSD and NetBSD, you do this by editing <TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
>, by changing
the lines you need, like this</P
><PRE
CLASS="PROGRAMLISTING"
>net.inet.ip.forwarding=1
net.inet6.ip6.forwarding=1</PRE
><P
>On FreeBSD, you conventionally do the corresponding change by putting these
lines in your <TT
CLASS="FILENAME"
>/etc/rc.conf</TT
></P
><PRE
CLASS="PROGRAMLISTING"
>gateway_enable="YES" #for ipv4
ipv6_gateway_enable="YES" #for ipv6</PRE
><P
>The net effect is identical, the FreeBSD <SPAN
CLASS="APPLICATION"
>rc</SPAN
> script sets the two
values via the <SPAN
CLASS="APPLICATION"
>sysctl</SPAN
> command. However, a larger part of
the FreeBSD configuration is centralized into the <TT
CLASS="FILENAME"
>rc.conf</TT
> file. </P
><P
>Are both of the interfaces you intend to use up and running? Use
<KBD
CLASS="USERINPUT"
>ifconfig -a</KBD
>, or <KBD
CLASS="USERINPUT"
>ifconfig</KBD
> 
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>interface_name</I
></SPAN
> to find out.</P
><P
>If you still intend to allow any traffic initiated by machines on the
inside, your <TT
CLASS="FILENAME"
>/etc/pf.conf</TT
> could look roughly like
this<A
NAME="AEN707"
HREF="#FTN.AEN707"
><SPAN
CLASS="footnote"
>[14]</SPAN
></A
>:</P
><PRE
CLASS="PROGRAMLISTING"
>ext_if = "ep0" # macro for external interface - use tun0 for PPPoE
int_if = "ep1"  # macro for internal interface
localnet = $int_if:network
# ext_if IP address could be dynamic, hence ($ext_if)
match out on $ext_if from $localnet nat-to ($ext_if)
block all
pass inet proto tcp from { self, $localnet } </PRE
><P
>or if you are running a pre-OpenBSD 4.7 version:</P
><PRE
CLASS="PROGRAMLISTING"
>ext_if = "ep0" # macro for external interface - use tun0 for PPPoE
int_if = "ep1"  # macro for internal interface
localnet = $int_if:network
# ext_if IP address could be dynamic, hence ($ext_if)
nat on $ext_if from $localnet to any -&gt; ($ext_if) 
block all
pass inet proto tcp from { self, $localnet } </PRE
><P
>Note the use of macros to assign logical names to the network interfaces.
Here 3Com cards are used, but this is the last time during this lecture
we will find this of any interest whatsoever. In truly simple setups like
this one, we may not gain very much by using macros like these, but once
the rule sets grow somewhat larger, you will learn to appreciate the 
readability this adds to the rule sets</P
><P
>Also note the rules where the network address translations happens.
<KBD
CLASS="USERINPUT"
>match</KBD
> rules were introduced in OpenBSD 4.6 as a
way to apply actions without affecting the
<KBD
CLASS="USERINPUT"
>block</KBD
> or <KBD
CLASS="USERINPUT"
>pass</KBD
> status.
In OpenBSD 4.7, <KBD
CLASS="USERINPUT"
>nat</KBD
> was demoted to
<KBD
CLASS="USERINPUT"
>nat-to</KBD
>, one of several possible actions on
<KBD
CLASS="USERINPUT"
>match</KBD
> or <KBD
CLASS="USERINPUT"
>pass</KBD
> rules. In
both cases this is where we handle the network address translation
from the non-routable address inside your local net to the sole
official address we assume has been assigned to you.</P
><P
>The parentheses surrounding the last part of the nat rule
<KBD
CLASS="USERINPUT"
>($ext_if)</KBD
> serve to compensate for the
possibility that the IP address of the external interface may be
dynamically assigned. This detail will ensure that your network
traffic runs without serious interruptions even if the external IP
address changes.</P
><P
>On the other hand, this rule set probably allows more traffic than
what you actually want to pass out of your network. In one network where I have done a fair bit of work over the years, 
the equivalent macro is</P
><PRE
CLASS="PROGRAMLISTING"
>client_out = "{ ftp-data, ftp, ssh, domain, pop3, auth, nntp, http,\
                https, 446, cvspserver, 2628, 5999, 8000, 8080 }"</PRE
><P
>with the rule</P
><PRE
CLASS="PROGRAMLISTING"
>pass inet proto tcp from $localnet to port $client_out</PRE
><P
>This may be a somewhat peculiar selection of ports, but it's exactly
what the users in that network need.  Some of the numbered ports were
needed for specific applications.  Your needs probably differ in some
specifics, but this should cover at least some of the more useful
services.</P
><P
>In addition, we have a few other pass rules.  We will be returning to some
of the more interesting ones rather soon.  One pass rule which is useful
to those of us who want the ability to administer our machines from 
elsewhere is</P
><PRE
CLASS="PROGRAMLISTING"
>pass in inet proto tcp to port ssh</PRE
><P
>or for that matter</P
><PRE
CLASS="PROGRAMLISTING"
>pass in inet proto tcp to $ext_if port ssh</PRE
><P
>whichever you like.  Lastly we need to make the name service and time
keeping work for our clients</P
><PRE
CLASS="PROGRAMLISTING"
>udp_services = "{ domain, ntp }"</PRE
><P
>supplemented with a rule which passes the traffic we want through our firewall:</P
><PRE
CLASS="PROGRAMLISTING"
>pass quick inet proto { tcp, udp } to port $udp_services keep state</PRE
><P
>Note the <B
CLASS="COMMAND"
>quick</B
> keyword in this rule.  We have
started writing rule sets which consist of several rules, and it is
time to take a look at the relationships between the rules in a rule
set.  The rules are evaluated from top to bottom, in the sequence they
are written in the configuration file.  For each packet or
connection evaluated by PF, <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>the last matching rule</I
></SPAN
> in
the rule set is the one which is applied.  The
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>quick</I
></SPAN
> keyword offers an escape from the ordinary
sequence.  When a packet matches a <KBD
CLASS="USERINPUT"
>quick</KBD
> rule, the packet is treated
according to the present rule.  The rule processing stops without
considering any further rules which might have matched the packet.
Quite handy when you need a few isolated exceptions to your general
rules.</P
><P
>It is worth noting that we used one rule for both the domain name
service (<KBD
CLASS="USERINPUT"
>domain</KBD
> and time synchronization
(<KBD
CLASS="USERINPUT"
>ntp</KBD
>).  The most important reason for this is
that both protocols under certain circumstances communicate alternately
over TCP and UDP.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="FTPPROBLEM"
></A
>That sad old FTP thing</H1
><P
>The short list of real life TCP ports we looked at a few moments back
contained, among other things, FTP. FTP is a sad old thing and a
problem child, emphatically so for anyone trying to combine FTP and firewalls. 
FTP is an old and weird protocol, with a lot to not like.  The most common
points against it, are</P
><P
></P
><UL
><LI
><P
>Passwords are transferred in the clear</P
></LI
><LI
><P
>The protocol demands the use of at least two TCP connections (control 
and data) on separate ports</P
></LI
><LI
><P
>When a session is established, data is communicated via ports selected
at random</P
></LI
></UL
><P
>All of these points make for challenges security-wise, even before
considering any potential weaknesses in client or server software
which may lead to security issues.  These things have tended to happen.</P
><P
>Under any circumstances, other more modern and more secure options
for file transfer exist, such as <SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/sftp"
TARGET="_top"
>sftp</A
></SPAN
> or
<SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/scp"
TARGET="_top"
>scp</A
></SPAN
>, which feature both authentication
and data transfer via encrypted connections.  Competent IT 
professionals should have a preference for some other form of file
transfer than FTP.</P
><P
>Regardless of our professionalism and preferences, we are all too
aware that at times we will need to handle things we would prefer not
to.  In the case of FTP through firewalls, the main part of our
handling consists of redirecting the traffic to a small program which
is written specifically for this purpose.</P
><P
>Depending on your configuration, which operating system you are using
as the platform for your PF firewall and how you count them, three or
four different options are available for this particular task.  </P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./warning.jpg"
HSPACE="5"
ALT="Warning"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If your configuration is based on a PF version that is old enough to warrant using any FTP proxy other than the first one here, I <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>strongly</I
></SPAN
> urge you to upgrade to a more recent system.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="FRESH-FTP-PROXY"
>If We Have To: ftp-proxy With Divert or Redirection</A
></H2
><P
>Enabling FTP transfers through your gateway is amazingly simple, thanks to the FTP proxy program included in the OpenBSD base system. The program is called, you guessed it, <KBD
CLASS="USERINPUT"
><A
HREF="http://man.openbsd.org/ftp-proxy"
TARGET="_top"
>ftp-proxy</A
></KBD
>.</P
><P
>  The FTP protocol being what it is, the proxy needs to dynamically insert rules in your rule set. <KBD
CLASS="USERINPUT"
>ftp-proxy</KBD
> interacts with your configuration via an <I
CLASS="FIRSTTERM"
>anchor</I
>
  where the proxy inserts and deletes the rules it constructs to handle your FTP traffic.</P
><P
>To enable <KBD
CLASS="USERINPUT"
>ftp-proxy</KBD
>, you need to add this line to your <TT
CLASS="FILENAME"
>/etc/rc.conf.local</TT
> file:</P
><PRE
CLASS="PROGRAMLISTING"
>ftpproxy_flags=""</PRE
><P
>Or, if you want to keep text file editing to a minimum and you're running a recent-ish version of  OpenBSD, you can use <SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/rcctl"
TARGET="_top"
>rcctl</A
></SPAN
>to enable and start the daemon:
      </P
><PRE
CLASS="SCREEN"
>$ doas rcctl enable ftpproxy	
$ doas rcctl start ftpproxy	
      </PRE
><P
>If you want to start the proxy in IPv6 mode, you enable and start the <KBD
CLASS="USERINPUT"
>ftpproxy6</KBD
> service in the same manner.
      </P
><P
>On FreeBSD, you also need to add</P
><PRE
CLASS="PROGRAMLISTING"
>ftpproxy_enable="YES"</PRE
><P
>You can start the proxy manually by running <KBD
CLASS="USERINPUT"
>/usr/sbin/ftp-proxy</KBD
> if you like, and you may in fact want to in order to check that the changes to the PF configuration we are about to do have the effect we want. </P
><P
>For a basic configuration, you only need to add three elements to your <TT
CLASS="FILENAME"
>/etc/pf.conf</TT
>. First, the anchor:</P
><PRE
CLASS="PROGRAMLISTING"
>anchor "ftp-proxy/*"</PRE
><P
>In pre-OpenBSD 4.7 based versions, two anchors were needed:</P
><PRE
CLASS="PROGRAMLISTING"
>nat-anchor "ftp-proxy/*"
rdr-anchor "ftp-proxy/*"</PRE
><P
>The proxy will insert the rules it generates for the FTP sessions here. Then you also need a pass rule to let ftp traffic in to the proxy.</P
><PRE
CLASS="PROGRAMLISTING"
>pass in quick inet proto tcp to port ftp divert-to 127.0.0.1 port 8021</PRE
><P
>Note the <KBD
CLASS="USERINPUT"
>divert-to</KBD
> part. This diverts the traffic to the local port where the proxy listens. Also make sure both the anchor and the divert rule are placed before any match rules for NAT.</P
><P
>Pre-<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>OpenBSD 5.0</I
></SPAN
> proxies, used <KBD
CLASS="USERINPUT"
>rdr-to</KBD
>:</P
><PRE
CLASS="PROGRAMLISTING"
>pass in quick proto tcp to port ftp rdr-to 127.0.0.1 port 8021
pass in quick inet6 proto tcp to port ftp rdr-to ::1 port 8021</PRE
><P
>And finally, the pre-OpenBSD 4.7 version of this rule is</P
><PRE
CLASS="PROGRAMLISTING"
>rdr pass on $int_if proto tcp from any to any port ftp -&#62; 127.0.0.1 \
         port 8021</PRE
><P
>(IPv4 only here to encourage you to upgrade to something modern.) Finally, add a <KBD
CLASS="USERINPUT"
>pass</KBD
> rule to let the packets pass from the proxy to the rest of the world:</P
><PRE
CLASS="PROGRAMLISTING"
>pass out proto tcp from $proxy to any port ftp </PRE
><P
>where <KBD
CLASS="USERINPUT"
>$proxy</KBD
> expands to the address the proxy daemon is bound to.</P
><P
>Reload your PF configuration, </P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>doas pfctl -f /etc/pf.conf</KBD
></PRE
><P
>and before you know it, your users will thank you for making FTP work.</P
><P
>This example covers a basic setup where the clients in your local net need to contact FTP servers elsewhere. The basic configuration here should work well with most combinations of FTP clients and servers. As you will notice from looking at the man page, you can change the proxy's behavior in various ways by adding options to the <KBD
CLASS="USERINPUT"
>ftpproxy_flags=</KBD
> line. You may bump into clients or servers with specific quirks that you need to compensate for in your configuration, or you may want to integrate the proxy in your setup in specific ways such as assigning FTP traffic to a specific queue. For these and other finer points of <KBD
CLASS="USERINPUT"
>ftp-proxy</KBD
> configuration, your best bet is to start by studying the man page.</P
><P
>If you are looking for ways to run an FTP server protected by PF and <KBD
CLASS="USERINPUT"
>ftp-proxy</KBD
>, you could look into running a separate <KBD
CLASS="USERINPUT"
>ftp-proxy</KBD
> in reverse mode (using the <KBD
CLASS="USERINPUT"
>-R</KBD
> option), on a separate port with its own redirecting pass rule.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="HISTORICAL-DEPRECATED"
>Historical FTP proxies: do not use</A
></H2
><P
>Various older PF versions still linger in some systems. The content that follows is <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> recommended, 
but is kept here mainly because any attempt at removing it has produced requests to bring it back.</P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./warning.jpg"
HSPACE="5"
ALT="Warning"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If your configuration is based on a PF version that is old enough to warrant using any of the FTP proxies described in the following paragraphs, 
I <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>strongly</I
></SPAN
> urge you to upgrade to a more recent system.</P
></TD
></TR
></TABLE
></DIV
><P
>We will present the antiquated solutions in roughly chronological order according to their
ages.  The original FTP proxy for PF is described below in <A
HREF="#FTP-PROXY"
>the Section called <I
>Ancient FTP through NAT: <SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
></I
></A
>.  We then move on to two newer, intermediate
solutions developed by Camiel Dobbelaar in <A
HREF="#FTPSESAME"
>the Section called <I
>Ancient: FTP, PF and routable addresses: <SPAN
CLASS="APPLICATION"
>ftpsesame</SPAN
>, <SPAN
CLASS="APPLICATION"
>pftpx</SPAN
> and <SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
>!</I
></A
>
before finally moving on to the modern FTP proxy which was introduced
in OpenBSD 3.9 in <A
HREF="#NEWFTPPROXY"
>the Section called <I
><SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
>, slightly new style</I
></A
>. </P
><DIV
CLASS="SECTION"
><HR><H3
CLASS="SECTION"
><A
NAME="FTP-PROXY"
>Ancient FTP through NAT: <SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
></A
></H3
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./warning.jpg"
HSPACE="5"
ALT="Warning"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If your configuration is based on a PF version that is old enough to warrant using this FTP proxy, I <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>strongly</I
></SPAN
> urge you to upgrade to a more recent system.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./note.jpg"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>OpenBSD 3.8 or earlier <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>equivalents</I
></SPAN
> only</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This section is headed for <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>purely historical</I
></SPAN
>
status when the last PF port to other systems has caught up.  In
November 2005, the old <SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
>
(<TT
CLASS="FILENAME"
>/usr/libexec/ftp-proxy</TT
>) was replaced in
OpenBSD-current with the new <SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
>,
which lives in <TT
CLASS="FILENAME"
>/usr/sbin</TT
>. This is the software
which is included in OpenBSD 3.9 onwards and what you will be using on
modern PF versions. See <A
HREF="#NEWFTPPROXY"
>the Section called <I
><SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
>, slightly new style</I
></A
> for details.</P
></TD
></TR
></TABLE
></DIV
><P
>The old style <SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
> which is a part of
the base system on systems which offer a PF version based on
OpenBSD3.8 or earlier is usually called via the
<SPAN
CLASS="APPLICATION"
>inetd</SPAN
> "super server" via an appropriate
<TT
CLASS="FILENAME"
>/etc/inetd.conf</TT
> entry.<A
NAME="AEN852"
HREF="#FTN.AEN852"
><SPAN
CLASS="footnote"
>[15]</SPAN
></A
></P
><P
>The line quoted here specifies that
<SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
> runs in NAT mode on the loopback
interface, <TT
CLASS="FILENAME"
>lo0</TT
>:</P
><PRE
CLASS="PROGRAMLISTING"
>127.0.0.1:8021 stream tcp nowait root /usr/libexec/ftp-proxy \
  ftp-proxy -n</PRE
><P
>This line is by default in your <TT
CLASS="FILENAME"
>inetd.conf</TT
>, commented out
with a <KBD
CLASS="USERINPUT"
>#</KBD
> character at the beginning of the line.
To enable your change, you restart inetd. </P
><P
>On FreeBSD, NetBSD and other rcNG based BSDs you do this with the
command</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>FreeBSD$</SAMP
> <KBD
CLASS="USERINPUT"
>doas /etc/rc.d/inetd restart</KBD
></PRE
><P
>or equivalent.  Consult man 8 inetd if you are unsure.  At this
point <SPAN
CLASS="APPLICATION"
>inetd</SPAN
> is running with your new
settings loaded.</P
><P
>Now for the actual redirection.  Redirection rules and NAT rules fall
into the same rule class.  These rules may be referenced directly by
other rules, and filtering rules may depend on these rules.  Logically,
rdr and nat rules need to be defined before the filtering rules.</P
><P
>We insert our rdr rule immediately after the nat rule in our <TT
CLASS="FILENAME"
>/etc/pf.conf</TT
></P
><PRE
CLASS="PROGRAMLISTING"
>rdr on $int_if proto tcp from any to any port ftp -&gt; 127.0.0.1 \
         port 8021</PRE
><P
>In addition, the redirected traffic must be allowed to pass. We achive this with</P
><PRE
CLASS="PROGRAMLISTING"
>pass in on $ext_if inet proto tcp from port ftp-data to ($ext_if) \
    user proxy flags S/SA keep state</PRE
><P
>Save <TT
CLASS="FILENAME"
>pf.conf</TT
>, then load the new rules with</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>doas pfctl -f /etc/pf.conf</KBD
></PRE
><P
>At this point you will probably have users noticing that FTP works before 
you get around to telling them what you've done. </P
><P
>This example assumes you are using NAT on a gateway with non routable 
addresses on the inside.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H3
CLASS="SECTION"
><A
NAME="FTPSESAME"
>Ancient: FTP, PF and routable addresses: <SPAN
CLASS="APPLICATION"
>ftpsesame</SPAN
>, <SPAN
CLASS="APPLICATION"
>pftpx</SPAN
> and <SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
>!</A
></H3
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./warning.jpg"
HSPACE="5"
ALT="Warning"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If your configuration is based on a PF version that is old enough to warrant using any of the following FTP proxy programs, I <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>strongly</I
></SPAN
> urge you to upgrade to a more recent system.</P
></TD
></TR
></TABLE
></DIV
><P
>In cases where the local network uses official, routable address
inside the firewall, I must confess I've had trouble making
<SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
> work properly.  When I'd already
spent too much time on the problem, I was rather relieved to find a
solution to this specific problen offered by a friendly Dutchman
called Camiel Dobbelaar in the form of a daemon called
<SPAN
CLASS="APPLICATION"
>ftpsesame</SPAN
>.</P
><P
>Local networks using official addresses inside a firewall are
apparently rare enough that I'll skip over any further treatment. If
you need this and you are running OpenBSD 3.8 or earlier or one of the
other PF enabled operating systems, you could do worse than installing
<SPAN
CLASS="APPLICATION"
>ftpsesame</SPAN
>.</P
><P
>On FreeBSD, <SPAN
CLASS="APPLICATION"
>ftpsesame</SPAN
> is available through
the ports system as <TT
CLASS="FILENAME"
>ftp/ftpsesame</TT
>.
Alternatively you can download <SPAN
CLASS="APPLICATION"
>ftpsesame</SPAN
>
from Sentia at <A
HREF="http://www.sentia.org/projects/ftpsesame/"
TARGET="_top"
>http://www.sentia.org/projects/ftpsesame/</A
>.</P
><P
>Once installed and running, <SPAN
CLASS="APPLICATION"
>ftpsesame</SPAN
> hooks
into your rule set via an anchor, a named sub-ruleset. The
documentation consists of a man page with examples which you can more
likely than not simply copy and paste.</P
><P
><SPAN
CLASS="APPLICATION"
>ftpsesame</SPAN
> never made it into the base
system, and Camiel went on to write a new solution to the same set of
problems. </P
><P
>The new program, at first called <SPAN
CLASS="APPLICATION"
>pftpx</SPAN
>, is
available from <A
HREF="http://www.sentia.org/downloads/pftpx-0.8.tar.gz"
TARGET="_top"
>http://www.sentia.org/downloads/pftpx-0.8.tar.gz</A
>
and through the FreeBSD ports system as
<TT
CLASS="FILENAME"
>ftp/pftpx</TT
>.  <SPAN
CLASS="APPLICATION"
>pftpx</SPAN
> comes with a fairly complete and well written man page to get you started.</P
><P
>A further developed version, suitably renamed as the new
<SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
>, became a part of the the OpenBSD
base system in time for the OpenBSD 3.9.  The new program,
<TT
CLASS="FILENAME"
>/usr/sbin/ftp-proxy</TT
>, and how to set it up, is
described in <A
HREF="#NEWFTPPROXY"
>the Section called <I
><SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
>, slightly new style</I
></A
> below.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H3
CLASS="SECTION"
><A
NAME="NEWFTPPROXY"
><SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
>, slightly new style</A
></H3
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./warning.jpg"
HSPACE="5"
ALT="Warning"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If your configuration is based on a PF version that is old enough to warrant using the FTP proxy described here, I <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>strongly</I
></SPAN
> urge you to upgrade to a more recent system.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./note.jpg"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>Ancient: For OpenBSD 3.9 and newer</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If you are upgrading to OpenBSD 3.9 or newer equivalents or working
from a fresh OpenBSD install, this is the
<SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
> version to use.</P
></TD
></TR
></TABLE
></DIV
><P
>Just like its predecessor, the <SPAN
CLASS="APPLICATION"
>pftpx</SPAN
>
successor <SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
> configuration is mainly
a matter of cut and paste from the man page.</P
><P
>If you are upgrading to the new <SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
>
from an earlier version, you need to remove the
<SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
> line from your
<TT
CLASS="FILENAME"
>inetd.conf</TT
> file and restart
<SPAN
CLASS="APPLICATION"
>inetd</SPAN
> or disable it altogether if your
setup does not require a running <SPAN
CLASS="APPLICATION"
>inetd</SPAN
>.</P
><P
>Next, enable <SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
> by adding the following line to
your <TT
CLASS="FILENAME"
>/etc/rc.conf.local</TT
> or <TT
CLASS="FILENAME"
>/etc/rc.conf</TT
></P
><PRE
CLASS="PROGRAMLISTING"
>ftpproxy_flags=""</PRE
><P
>You can start the proxy manually by running
<KBD
CLASS="USERINPUT"
>/usr/sbin/ftp-proxy</KBD
> if you like.</P
><P
>Moving on to the <TT
CLASS="FILENAME"
>pf.conf</TT
> file, you need two
anchor definitions in the NAT section:</P
><PRE
CLASS="PROGRAMLISTING"
>nat-anchor "ftp-proxy/*"
rdr-anchor "ftp-proxy/*"</PRE
><P
>Both are needed, even if your setup does not use NAT.  If you are
migrating from a previous version, your rule set probably contains the
appropriate redirection already.  If it does not, you add it:</P
><PRE
CLASS="PROGRAMLISTING"
>rdr pass on $int_if proto tcp from any to any port ftp -&gt; 127.0.0.1 \
         port 8021</PRE
><P
>Moving on down to the filtering rules, you add an anchor for the proxy to fill in,</P
><PRE
CLASS="PROGRAMLISTING"
>anchor "ftp-proxy/*"</PRE
><P
>and finally a pass rule to let the packets pass from the proxy to the rest of the world</P
><PRE
CLASS="PROGRAMLISTING"
>pass out proto tcp from $proxy to any port 21 keep state</PRE
><P
>where <KBD
CLASS="USERINPUT"
>$proxy</KBD
> expands to the address the proxy
daemon is bound to.</P
><P
>This example covers the simple setup with clients who need to contact
FTP servers elsewhere.  For other variations and more complicated
setups, see the <SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
> man page.</P
><P
>If you are looking for ways to run an FTP server protected by PF and
<SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
>, you could look into running a
separate <SPAN
CLASS="APPLICATION"
>ftp-proxy</SPAN
> in reverse mode (using
the <KBD
CLASS="USERINPUT"
>-R</KBD
> option).</P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="TROUBLESHOOT"
></A
>Making your network troubleshooting friendly</H1
><P
>Making your network troubleshooting friendly is a potentially large
subject.  At most times, the debugging or troubleshooting friendliness
of your TCP/IP network depends on how you treat the Internet protocol
which was designed specifically with debugging in mind, the
<I
CLASS="FIRSTTERM"
>Internet Control Message Protocol</I
>, or
<I
CLASS="FIRSTTERM"
>ICMP</I
> as it is usually abbreviated.</P
><P
>ICMP is the protocol for sending and receiving <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>control messages</I
></SPAN
>
between hosts and gateways, mainly to provide feedback to a sender
about any unusual or difficult conditions en route to the target host. </P
><P
>There is a lot of ICMP traffic which usually just happens in the
background while you are surfing the web, reading mail or transferring
files.  Routers (you are aware that you are building one, right?) use
ICMP to negotiate packet sizes and other transmission parameters in a
process often referred to as <I
CLASS="FIRSTTERM"
>path MTU discovery</I
>.  </P
><P
>You may have heard admins referring to ICMP as either 'just evil', or,
if their understanding runs a little deeper, 'a necessary evil'.  The
reason for this attitude is purely historical. The reason can be found
a few years back when it was discovered that several operating systems
contained code in their networking stack which could make a machine
running one of the affected systems crash and fall over, or in some
cases just do really strange things, with a sufficiently large ICMP
request.</P
><P
>One of the companies which was hit hard by this was Microsoft, and you
can find rather a lot of material on the 'ping of death' bug by using
your favorite search engine.  This all happened in the second half of
the 1990s, and all modern operating systems, at least the ones we can
read, have thoroughly sanitized their network code since then.  At
least that's what we are lead to believe.</P
><P
>One of the early workarounds was to simply block either all ICMP
traffic or at least ICMP ECHO, which is what ping uses.  Now these
rule sets have been around for roughly ten years, and the people who
put them there are still scared.</P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="DOWEPASS"
>Then, do we let it all through?</A
></H2
><P
>The obvious question then becomes, if ICMP is such a good and useful
thing, should we not let it all through, all the time?  The answer is,
'It depends'.</P
><P
>Letting diagnostic traffic pass unconditionally of course makes
debugging easier, but it also makes it relatively easy for others to
extract information about your network.  That means that a rule like</P
><PRE
CLASS="PROGRAMLISTING"
>pass inet proto icmp</PRE
><P
>might not be optimal if you want to cloak the internal workings of
your network in a bit of mystery.  In all fairness it should also be
said that you might find some ICMP traffic quite harmlessly riding
piggyback on your keep state rules.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="ICMPSTOPATGW"
>The easy way out: The buck stops here</A
></H2
><P
>The easiest solution could very well be to let all ICMP traffic from
your local net through and let probes from elsewhere stop at your gateway:</P
><PRE
CLASS="PROGRAMLISTING"
>pass inet proto icmp from $localnet 
pass inet proto icmp to $ext_if </PRE
><P
>Stopping probes at the gateway might be an attractive option anyway,
but let us have a look at a few other options which will show you some
of PF's flexibility.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="LETPINGTHRU"
>Letting <SPAN
CLASS="APPLICATION"
>ping</SPAN
> through</A
></H2
><P
>The rule set we have developed so far has one clear disadvantage:
common troubleshooting commands such as
<SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/ping"
TARGET="_top"
>ping</A
></SPAN
> and
<SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/traceroute"
TARGET="_top"
>traceroute</A
></SPAN
> will not work. That may not
matter too much to your users, and since it was the
<SPAN
CLASS="APPLICATION"
>ping</SPAN
> command which scared people into
filtering or blocking ICMP traffic in the first place, there are
apparently some people who feel we are better off without it. If you
are in my perceived target audience, you will be rather fond of having
those troubleshooting tools available.  With a couple of small
additions to the rule set, they will be.
<SPAN
CLASS="APPLICATION"
>ping</SPAN
> uses ICMP, and in order to keep our
rule set tidy, we start by defining another macro:</P
><PRE
CLASS="PROGRAMLISTING"
>icmp_types = "echoreq"</PRE
><P
>and a rule which uses the definition,</P
><PRE
CLASS="PROGRAMLISTING"
>pass inet proto icmp all icmp-type $icmp_types </PRE
><P
>You may need more or other types of ICMP packets to go through,
and you can then expand <KBD
CLASS="USERINPUT"
>icmp_types</KBD
> to a list of
those packet types you want to allow.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="HELPTRACEROUTE"
>Helping <SPAN
CLASS="APPLICATION"
>traceroute</SPAN
></A
></H2
><P
><SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/traceroute"
TARGET="_top"
>traceroute</A
></SPAN
> is another command which is
quite useful when your users claim that the Internet isn't working.
By default, Unix <SPAN
CLASS="APPLICATION"
>traceroute</SPAN
> uses UDP
connections according to a set formula based on destination.  The rule
below works with the <SPAN
CLASS="APPLICATION"
>traceroute</SPAN
> command on
all unixes I've had access to, including GNU/Linux:</P
><PRE
CLASS="PROGRAMLISTING"
># allow out the default range for traceroute(8):
# "base+nhops*nqueries-1" (33434+64*3-1)
pass out on $ext_if inet proto udp to port 33433 &gt;&lt; 33626</PRE
><P
>Experience so far indicates that <SPAN
CLASS="APPLICATION"
>traceroute</SPAN
>
implementations on other operating systems work roughly the
same. Except, of course, Microsoft Windows.  On that platform,
<TT
CLASS="FILENAME"
>TRACERT.EXE</TT
> uses ICMP ECHO for this purpose. So
if you want to let Windows traceroutes through, you only need the
first rule. Unix <SPAN
CLASS="APPLICATION"
>traceroutes</SPAN
> can be
instructed to use other protocols as well, and will behave remarkably
like its Microsoft counterpart if you use its
<KBD
CLASS="USERINPUT"
>-I</KBD
> command line option.  You can check the
<SPAN
CLASS="APPLICATION"
>traceroute</SPAN
> man page (or its source code,
for that matter) for all the details.</P
><P
>Under any circumstances, this solution was lifted from an openbsd-misc
post.  I've found that list, and the searchable list archives
(accessible among other places from
<A
HREF="http://marc.info/"
TARGET="_top"
>http://marc.info/</A
>),
to be a very valuable resource whenever you need OpenBSD or PF related
information.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="PATHMTUDISC"
>Path MTU discovery</A
></H2
><P
>The last bit I will remind you about when it comes to troubleshooting
is the 'path MTU discovery'.  Internet protocols are designed to be
device independent, and one consequence of device independence is that
you can not always predict reliably what the optimal packet size is
for a given connection.  The main constraint on your packet size is
called the <I
CLASS="FIRSTTERM"
>Maximum Transmission Unit</I
>, or 
<I
CLASS="FIRSTTERM"
>MTU</I
>, which sets the upper limit on the 
packet size for an interface.  The <SPAN
CLASS="APPLICATION"
>ifconfig</SPAN
> 
command will show you the MTU for your network interfaces.</P
><P
>The way modern TCP/IP implementations work, they expect to be able to
determine the right packet size for a connection through a process
which simply puts involves sending packets of varying sizes with the
'Do not fragment' flag set, expecting an ICMP return packet indicating
"type 3, code 4", when the upper limit has been reached.  Now you
don't need to dive for the RFCs right away.  Type 3 means "destination
unreachable", while code 4 is short for "fragmentation needed, but the
do not fragment flag is set".  So if your connections to networks
which may have other MTUs than your own seem sub-optimal, and you do
not need to be that specific, you could try changing your list of ICMP
types slightly to let the Destination unreachable packets through, too:</P
><PRE
CLASS="PROGRAMLISTING"
>icmp_types = "{ echoreq, unreach }"</PRE
><P
>as we can see, this means we do not need to change the pass rule itself:</P
><PRE
CLASS="PROGRAMLISTING"
>pass inet proto icmp all icmp-type $icmp_types</PRE
><P
>It's also possible to just allow the code 4 of type 3, instead of all codes.</P
><PRE
CLASS="PROGRAMLISTING"
>pass inet proto icmp all icmp-type unreach code needfrag </PRE
><P
>PF lets you filter on all variations of ICMP types and codes, and if
you want to delve into what to pass and not of ICMP traffic, the list
of possible types and codes are documented in the icmp(4) and icmp6(4)
man pages.  The background information is available in the RFCs<A
NAME="AEN1026"
HREF="#FTN.AEN1026"
><SPAN
CLASS="footnote"
>[16]</SPAN
></A
>
.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="HYGIENE"
></A
>Network hygiene: Blocking, scrubbing and so on</H1
><P
>Our gateway does not feel quite complete without a few more items in the
configuration which will make it behave a bit more sanely towards hosts on
the wide net and our local network. </P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="BLOCKPOLICY"
><KBD
CLASS="USERINPUT"
>block-policy</KBD
></A
></H2
><P
><KBD
CLASS="USERINPUT"
>block-policy</KBD
> is an option which can be set in
the <KBD
CLASS="USERINPUT"
>options</KBD
> part of the ruleset, which precedes
the redirection and filtering rules. This option determines which
feedback, if any, PF will give to hosts which try to create connections
which are subsequently blocked. The option has two possible values,
<KBD
CLASS="USERINPUT"
>drop</KBD
> which drops blocked packets with no
feedback, and <KBD
CLASS="USERINPUT"
>return</KBD
> which returns with status
codes such as <SAMP
CLASS="COMPUTEROUTPUT"
>Connection refused</SAMP
>
or similar.</P
><P
>The correct strategy for block policies has been the subject of rather
a lot of discussion.  We choose to play nicely and instruct our
firewall to issue returns:</P
><PRE
CLASS="PROGRAMLISTING"
>set block-policy return</PRE
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="SCRUB"
><KBD
CLASS="USERINPUT"
>scrub</KBD
></A
></H2
><P
>In PF versions up to OpenBSD 4.5 inclusive,
<KBD
CLASS="USERINPUT"
>scrub</KBD
> is a keyword which enables network packet
normalization, causing fragmented packets to be assembled and removing
ambiguity.  Enabling <KBD
CLASS="USERINPUT"
>scrub</KBD
> provides a measure
of protection against certain kinds of attacks based on incorrect
handling of packet fragments.  A number of supplementing options are
available, but we choose the simplest form which is suitable for most
configurations.</P
><PRE
CLASS="PROGRAMLISTING"
>scrub in all</PRE
><P
>Some services, such as NFS, require some specific fragment handling
options.  This is extensively documented in the PF user guide and man
pages provide all the information you could need.</P
><P
>In <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>OpenBSD 4.6</I
></SPAN
>, <KBD
CLASS="USERINPUT"
>scrub</KBD
> was demoted from standalone rule material to become an action you could attach to <KBD
CLASS="USERINPUT"
>pass</KBD
> or <KBD
CLASS="USERINPUT"
>match</KBD
> rules (the introduction of <KBD
CLASS="USERINPUT"
>match</KBD
> rules being one of the main new features in OpenBSD 4.6).  You should also note that for the new <KBD
CLASS="USERINPUT"
>scrub</KBD
> syntax, you need to supply at least one option in brackets.  The following works quite well for several networks in my care:</P
><PRE
CLASS="PROGRAMLISTING"
>match in all scrub (no-df max-mss 1440)</PRE
><P
>meaning, we clear the do not fragment bit and set the maximum segment size to 1440 bytes.  Other variations are possible, and even though the list of <KBD
CLASS="USERINPUT"
>scrub</KBD
> options shrank somewhat for the OpenBSD 4.6 version, you should be able to cater to various specific needs by consulting the man pages and some experimentation.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="ANTISPOOF"
><KBD
CLASS="USERINPUT"
>antispoof</KBD
></A
></H2
><P
><KBD
CLASS="USERINPUT"
>antispoof</KBD
> is a common special case of filtering
and blocking.  This mechanism protects against activity from spoofed
or forged IP addresses, mainly by blocking packets appearing on
interfaces and in directions which are logically not possible. </P
><P
>We specify that we want to weed out spoofed traffic coming in from the
rest of the world and any spoofed packets which, however unlikely,
were to originate in our own network:</P
><PRE
CLASS="PROGRAMLISTING"
>antispoof for $ext_if
antispoof for $int_if</PRE
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="UNROUTEABLES"
>Handling non-routable addresses from elsewhere</A
></H2
><P
>Even with a properly configured gateway to handle network address
translation for your own network, you may find yourself in the
unenviable position of having to compensate for other people's
misconfigurations.  </P
><P
>One depressingly common class of misconfigurations is the kind which
lets traffic with non-routable addresses out to the Internet.  Traffic
from non-routeable addresses have also played a part in several DOS
attack techniques, so it may be worth considering explicitly blocking
traffic from non-routeable addresses from entering your network.</P
><P
>One possible solution is the one outlined below, which for good
measure also blocks any attempt to initiate contact to non-routable
addresses through the gateway's external interface:</P
><PRE
CLASS="PROGRAMLISTING"
>martians = "{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, \
              10.0.0.0/8, 169.254.0.0/16, 192.0.2.0/24, \
              0.0.0.0/8, 240.0.0.0/4 }"

block drop in quick on $ext_if from $martians to any
block drop out quick on $ext_if from any to $martians</PRE
><P
>Here, the <KBD
CLASS="USERINPUT"
>martians</KBD
> macro denotes the RFC 1918
addresses and a few other ranges which are mandated by various RFCs
not to be in circulation on the open Internet. Traffic to and from
such addresses is quietly dropped on the gateway's external interface.</P
><P
>The specific details of how to implement this kind of protection will
vary, among other things according to your specific network
configuration.  Your network design could for example dictate that you
include or exclude other address ranges than these.</P
><P
>This completes our simple NATing firewall for a small local network.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="RDR2SERVERS"
></A
>A web server and a mail server on the inside</H1
><P
>Time passes, and needs change.  Rather frequently, a need to run
externally accessible services develops.  This quite frequently
becomes just a little harder because externally visible addresses are
either not available or too expensive, and running several other services
on a machine which is primarily a firewall is not a desirable option.</P
><P
>The redirection mechanisms in PF makes it relatively easy to keep
servers on the inside.  If we assume that we need to run a web server
which serves up data in clear text (http) and encrypted (https) and in
addition we want a mail server which sends and receives e-mail while
letting clients inside and outside the local network use a number of
well known submission and retrieval protocols, the following lines 
may be all that's needed in addition to the rule set we developed earlier:</P
><PRE
CLASS="PROGRAMLISTING"
>webserver = "192.168.2.7"
webports = "{ http, https }"
emailserver = "192.168.2.5"
email = "{ smtp, pop3, imap, imap3, imaps, pop3s }"

match in on $ext_if proto tcp to $ext_if port $webports rdr-to $webserver
match in on $ext_if proto tcp to $ext_if port $email rdr-to $emailserver

pass proto tcp from any to $webserver port $webports 
pass proto tcp from any to $emailserver port $email 
pass proto tcp from $emailserver to any port smtp </PRE
><P
>The combination of <KBD
CLASS="USERINPUT"
>match</KBD
> and <KBD
CLASS="USERINPUT"
>pass</KBD
> rules above is very close to the way things were done in pre-OpenBSD 4.7 PF versions, and if you are upgrading from a previous version, this is the kind of quick edit that could bridge the syntax gap quickly. But you could also opt to go for the new style, and write this slightly more compact version instead:</P
><PRE
CLASS="PROGRAMLISTING"
>pass in on $ext_if inet proto tcp to $ext_if port $webports rdr-to $webserver
pass in on $ext_if inet proto tcp to $ext_if port $email rdr-to $mailserver
pass on $int_if inet proto tcp to $webserver port $webports
pass on $int_if inet proto tcp to $mailserver port $email</PRE
><P
>in pre-OpenBSD 4.7 syntax, the equivalent rules are:</P
><PRE
CLASS="PROGRAMLISTING"
>webserver = "192.168.2.7"
webports = "{ http, https }"
emailserver = "192.168.2.5"
email = "{ smtp, pop3, imap, imap3, imaps, pop3s }"

rdr on $ext_if proto tcp from any to $ext_if port \
       $webports -&gt; $webserver
rdr on $ext_if proto tcp from any to $ext_if port \
       $email -&gt; $emailserver

pass proto tcp from any to $webserver port $webports 
pass proto tcp from any to $emailserver port $email 
pass proto tcp from $emailserver to any port smtp </PRE
><P
>Previous versions of this document had the flag 'synproxy' in the pass
rules, indicating that some backends might be in need of assistance during connection setup,
with the gateway handling the three way handshake on behalf of your server or client before
handing the connection over to the application.  The intention was to provide a
certain amount of protection against various SYN based attacks.  The general recommendation today is rather to keep things simple and fix the back end.</P
><P
>Rule sets for configurations with DMZ networks isolated behind
separate network interfaces and in some cases services running on
alternative ports will not necessarily be much different from this one.</P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="RDRFROMINSIDE"
>Taking care of your own - the inside</A
></H2
><P
>Everything I've said so far is excellent and correct as long as all you
are interested in is getting traffic from hosts outside your local net
to reach your servers.  </P
><P
>If you want the hosts in your local net to be able to use the services
on these machines, you will soon see that the traffic originating in
your local network most likely never reaches the external
interface. The external interface is where all the redirection and
translation happens, and consequently the redirections do not quite
work from the inside.  The problem is common enough that the PF
documentation lists four different solutions to the
problem.<A
NAME="AEN1097"
HREF="#FTN.AEN1097"
><SPAN
CLASS="footnote"
>[17]</SPAN
></A
></P
><P
>The options listed in the PF user guide are</P
><P
></P
><UL
><LI
><P
>'Split horizon' DNS, which means configuring your name service to
provide one set of replies for requests originating in the local net and
a different one for requests from elsewhere</P
></LI
><LI
><P
>  proxying using software such as <SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/nc"
TARGET="_top"
>nc</A
></SPAN
> (NetCat)</P
></LI
><LI
><P
>treating the local net as a special case for redirection and NAT.</P
><P
>We will be looking into this option (actually a pretty hackish workaround) below.</P
></LI
><LI
><P
>Or simply moving your servers to a separate network, aka a 'DMZ', with
only minor changes to your PF rules.</P
></LI
></UL
><P
>We need to intercept the network packets originating in the local
network and handle those connections correctly, making sure any
returning traffic is directed to the communication partner who
actually originated the connection.</P
><P
>Returning to our previous example, we achieve this by adding 
special case rules that mirror the ones designed to handle requests from the outside. First, the pass rules with redirections for OpenBSD 4.7 and newer:</P
><PRE
CLASS="PROGRAMLISTING"
>pass in on $ext_if inet proto tcp to $ext_if port $webports rdr-to $webserver
pass in on $ext_if inet proto tcp to $ext_if port $email rdr-to $mailserver
pass in log on $int_if inet proto tcp from $int_if:network to $ext_if port $webports rdr-to $webserver
pass in log on $int_if inet proto tcp from $int_if:network to $ext_if port $email rdr-to $mailserver
match out log on $int_if proto tcp from $int_if:network to $webserver port $webports nat-to $int_if
pass on $int_if inet proto tcp to $webserver port $webports
match out log on $int_if proto tcp from $int_if:network to $mailserver port $email nat-to $int_if
pass on $int_if inet proto tcp to $mailserver port $email</PRE
><P
>The first two rules are identical to the original ones. The next two intercept the traffic from the local network and the rdr-to actions in both rewrite the destination address much as the corresponding rules do for the traffic that originates elsewhere. The pass on $int_if rules serve the same purpose as in the earlier version.</P
><P
> 
The match rules with nat-to are there as a routing workaround. Without them, the webserver and mailserver hosts would route return traffic for the redirected connections directly back the hosts in the local network, where the traffic would not match any outgoing connection. With the nat-to in place, the servers consider the gateway as the source of the traffic, and will direct return traffic back the same path it came originally. The gateway of course matches the return traffic to the states created by connections from the clients in the local network, and applies the appropriate actions to return the traffic to the correct clients.</P
><P
>The equivalent rules for pre-OpenBSD 4.7 versions are at first sight a bit more confusing, but the end result is the same:</P
><PRE
CLASS="PROGRAMLISTING"
>rdr on $int_if proto tcp from $localnet to $ext_if \
       port $webports -&gt; $webserver
rdr on $int_if proto tcp from $localnet to $ext_if \
       port $email -&gt; $emailserver
no nat on $int_if proto tcp from $int_if to $localnet
nat on $int_if proto tcp from $localnet to $webserver \
       port $webports -&gt; $int_if 
nat on $int_if proto tcp from $localnet to $emailserver \
       port $email -&gt; $int_if </PRE
><P
>It is well worth noting that we do not need to touch the
<KBD
CLASS="USERINPUT"
>pass</KBD
> rules at all.</P
><P
>I've had the good fortune to witness via email or IRC the reactions of
several network admins at the point when the truth about this five
line reconfiguration sank in.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="TABLES"
></A
>Tables make your life easier</H1
><P
>By this time you may be thinking that this gets awfully static and
rigid.  There will after all be some kinds of data which are relevant
to filtering and redirection at a given time, but do not deserve to be
put into a configuration file!  Quite right, and PF offers mechanisms
for handling these situations as well.  Tables are one such feature,
mainly useful as lists of IP addresses which can be manipulated
without needing to reload the entire rule set, and where fast lookups
are desirable.  Table names are always enclosed in angle brackets, ie
&lt; &gt;, like this:</P
><PRE
CLASS="PROGRAMLISTING"
>table &lt;clients&gt; { 192.168.2.0/24, !192.168.2.5 }</PRE
><P
>here, the network <KBD
CLASS="USERINPUT"
>192.168.2.0/24</KBD
> is part of the table,
except the address <KBD
CLASS="USERINPUT"
>192.168.2.5</KBD
>, which is excluded
using the ! operator (logical NOT). It is also possible to load tables from
files where each item is on a separate line, such as the file <TT
CLASS="FILENAME"
>/etc/clients</TT
></P
><PRE
CLASS="PROGRAMLISTING"
>192.168.2.0/24
!192.168.2.5</PRE
><P
>which in turn is used to initialize the table in <TT
CLASS="FILENAME"
>/etc/pf.conf</TT
>:</P
><PRE
CLASS="PROGRAMLISTING"
>table &lt;clients&gt; persist file "/etc/clients"</PRE
><P
>Then, for example, you can change one of our earlier rules to read</P
><PRE
CLASS="PROGRAMLISTING"
>pass inet proto tcp from &lt;clients&gt; to any port $client_out \
         flags S/SA keep state</PRE
><P
>to manage outgoing traffic from your client computers. With this in hand, you can 
manipulate the table's contents live, such as</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>doas pfctl -t clients -T add 192.168.1/16</KBD
></PRE
><P
>Note that this changes the in-memory copy of the table only, meaning
that the change will not survive a power failure or other reboot
unless you arrange to store your changes.</P
><P
>You might opt to maintain the on-disk copy of the table using a cron
job which dumps the table content to disk at regular intervals, using
a command such as <KBD
CLASS="USERINPUT"
>pfctl -t clients -T show 
&gt;/etc/clients</KBD
>.  Alternatively, you could edit the
<TT
CLASS="FILENAME"
>/etc/clients</TT
> file and replace the in-memory table
contents with the file data:</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>doas pfctl -t clients -T replace -f /etc/clients</KBD
></PRE
><P
>For operations you will be performing frequently, you will sooner or
later end up writing shell scripts for tasks such as inserting or
removing items or replacing table contents. The only real limitations
lie in your own needs and your creativity.<A
NAME="AEN1149"
HREF="#FTN.AEN1149"
><SPAN
CLASS="footnote"
>[18]</SPAN
></A
></P
><P
>We will be returning to some handy uses of tables shortly, including a
few programs which interact with tables in useful ways.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="LOGGING"
></A
>Logging</H1
><P
>Up to now we have not mentioned much about logging.  To my mind
logging and by extension keeping track of what goes on in your
network, or at least having the ability to get the information easily
is an important part of staying in control of the network.
Fortunately PF provides the opportunity to log exactly what you want
by adding the <KBD
CLASS="USERINPUT"
>log</KBD
> keyword to the rules you want
logged.  You may want to limit the amount of data a bit by specifying
one interface where the logging is to be done.  You do this by adding</P
><PRE
CLASS="PROGRAMLISTING"
>set loginterface $ext_if</PRE
><P
>and then editing the rules you want to log, such as</P
><PRE
CLASS="PROGRAMLISTING"
>pass out log from &lt;clients&gt; to any port $email \
         label client-email keep state</PRE
><P
>This causes the traffic to be logged in a binary format which is
really only intended to be used as <SPAN
CLASS="APPLICATION"
>tcpdump</SPAN
>
input.  Note that <KBD
CLASS="USERINPUT"
>log</KBD
> here only logs the packet
which sets up the connection.  If you want to log
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>all</I
></SPAN
> traffic matching the rule, you use
<KBD
CLASS="USERINPUT"
>log (all)</KBD
> in the rule instead<A
NAME="AEN1166"
HREF="#FTN.AEN1166"
><SPAN
CLASS="footnote"
>[19]</SPAN
></A
>
.</P
><P
>The <I
CLASS="FIRSTTERM"
>label</I
> part creates a new set of counters
for various statistics for the rule.  This can be quite convenient if
you are invoicing others for bandwidth use, for example.</P
><P
>It is worth noting that from OpenBSD 4.1, the
<TT
CLASS="FILENAME"
>pflog</TT
> interface is cloneable, which means you can
configure as many as you need.  At the same time, the
<KBD
CLASS="USERINPUT"
>log</KBD
> syntax for each rule was extended to let
you specify on a per rule basis which <TT
CLASS="FILENAME"
>pflog</TT
>
interface to log to, ie</P
><PRE
CLASS="PROGRAMLISTING"
>pass log (all, to pflog2) inet proto tcp from $mailserver to any port smtp </PRE
><P
>to log outgoing SMTP traffic from the host
<KBD
CLASS="USERINPUT"
>$mailserver</KBD
> to elsewhere, with the log data
ending up at the <TT
CLASS="FILENAME"
>pflog2</TT
> interface.</P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="TCPDUMPEX"
>Taking a peek with <SPAN
CLASS="APPLICATION"
>tcpdump</SPAN
></A
></H2
><P
>Once you have enabled logging in one or more rules, PF logs via the
<SAMP
CLASS="COMPUTEROUTPUT"
>pflog0</SAMP
> interface, and stores binary
log data in the log file <TT
CLASS="FILENAME"
>/var/log/pflog</TT
>.  The log
file is useful for a permanent record and for those cases where you
want to periodically convert some of the data to other formats.
However, if you want to look at your traffic in real time, you can
tell <SPAN
CLASS="APPLICATION"
>tcpdump</SPAN
> to look at the
<SAMP
CLASS="COMPUTEROUTPUT"
>pflog0</SAMP
> log interface instead.</P
><P
>Here is what the output from a couple of log rules can look like on a lazy Thursday afternoon:</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>$ doas tcpdump -n -e -ttt -i pflog0
tcpdump: WARNING: pflog0: no IPv4 address assigned
tcpdump: listening on pflog0, link-type PFLOG
Feb 16 16:43:20.152187 rule 0/(match) block in on ep0: 194.54.59.189.2559 &#62; 
194.54.107.19.139: [|tcp] (DF)
Feb 16 16:48:26.073244 rule 27/(match) pass in on ep0: 61.213.167.236 &#62; 
194.54.107.19: icmp: echo request
Feb 16 16:49:09.563448 rule 0/(match) block in on ep0: 61.152.249.148.80 &#62; 
194.54.107.19.55609: [|tcp]
Feb 16 16:49:14.601022 rule 0/(match) block in on ep0: 194.54.59.189.3056 &#62; 
194.54.107.19.139: [|tcp] (DF)
Feb 16 16:53:10.110110 rule 0/(match) block in on ep0: 68.194.177.173 &#62; 
194.54.107.19: [|icmp]
Feb 16 16:55:54.818549 rule 27/(match) pass in on ep0: 61.213.167.237 &#62; 
194.54.107.19: icmp: echo request
Feb 16 16:57:55.577782 rule 27/(match) pass in on ep0: 202.43.202.16 &#62; 
194.54.107.19: icmp: echo request
Feb 16 17:01:27.108404 rule 0/(match) block in on ep0: 194.54.59.189.4520 &#62; 
194.54.107.19.139: [|tcp] (DF)
Feb 16 17:11:02.137310 rule 0/(match) block in on ep0: 222.73.4.154.80 &#62; 
194.54.107.19.55609: [|tcp]
Feb 16 17:14:05.739403 rule 0/(match) block in on ep0: 194.54.174.246.3970 &#62; 
194.54.107.19.135: [|tcp] (DF)
Feb 16 17:14:08.715163 rule 0/(match) block in on ep0: 194.54.174.246.3970 &#62; 
194.54.107.19.135: [|tcp] (DF)
Feb 16 17:14:09.308355 rule 0/(match) block in on ep0: 194.54.174.246.3970 &#62; 
194.54.107.19.135: [|tcp] (DF)
Feb 16 17:19:01.853730 rule 27/(match) pass in on ep0: 203.84.214.5 &#62; 
194.54.107.19: icmp: echo request</SAMP
></PRE
><P
>The PF User Guide has a section devoted to logging which contains a
number of very useful suggestions.  Combined with among other things
the <SPAN
CLASS="APPLICATION"
>tcpdump</SPAN
> man pages, you should be able
to extract any log data you will find useful.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="OTHERLOGTOOLS"
>Other log tools you may want to look into</A
></H2
><P
>The logs themselves and the various <SPAN
CLASS="APPLICATION"
>tcpdump</SPAN
>
options provide you with valuable tools to gain insight into what
happens in your network.  Not surprisingly, other tools have been
developed to operate on PF log data, collect statistics and do various
forms of graphing. </P
><P
>Of special note is Damien Miller's <TT
CLASS="FILENAME"
>pfflowd</TT
>, which
collects PF log data, converts to Cisco
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>NetFlow&trade;</I
></SPAN
> for further processing. Damien
also develops and maintains see <TT
CLASS="FILENAME"
>flowd</TT
> for
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>NetFlow&trade;</I
></SPAN
> collecting purposes.  This Cisco
originated data format is supported by a number of different products,
and the ability to generate data in this format may be important in
certain environments.</P
><P
>In OpenBSD 4.5, the <KBD
CLASS="USERINPUT"
>pflow</KBD
> virtual network interface was added.  Using the <KBD
CLASS="USERINPUT"
>pflow</KBD
> state option (or a global <KBD
CLASS="USERINPUT"
>set state-defaults pflow</KBD
> you can export <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>NetFlow&trade;</I
></SPAN
> data from the PF state table via the <KBD
CLASS="USERINPUT"
>pflow</KBD
>interfaces. <KBD
CLASS="USERINPUT"
>man pflow</KBD
> has more information, and this topic is covered in more detail in the second edition of <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
><A
HREF="http://nostarch.com/pf2.htm"
TARGET="_top"
>The Book of PF</A
></I
></SPAN
>. Some tips and descriptions of practical applications can be found in my blog article <A
HREF="http://bsdly.blogspot.com/2014/02/yes-you-too-can-be-evil-network.html"
TARGET="_top"
>Yes, You Too Can Be An Evil Network Overlord - On The Cheap With OpenBSD, pflow And nfsen</A
>.</P
><P
>One other log data application which is well worth noting is Daniel
Hartmeier's <TT
CLASS="FILENAME"
>pfstat</TT
>, which collects statistics
from PF logs and generates graphs from the data. It's a fairly
flexible package which takes a lot of the heavy lifting out of
presenting log data.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="LOGSIZES"
>But there are limits (an anecdote)</A
></H2
><P
>It might feel tempting at first to put something like this in</P
><PRE
CLASS="PROGRAMLISTING"
>block log all</PRE
><P
>- just to make sure you don't miss anything.  </P
><P
>The PF user guide contains a detailed description of how to make PF
log to a human readable text format via syslog, and this does sound
rather attractive.  I went through the procedure described there when
I set up my first PF configuration at work, and the experience sums up
rather neatly: Logging is useful, but by all means, be selective.
After a little more than an hour the PF text log file had grown to
more than a gigabyte, on a machine with less than ten gigabytes of
disk space total.</P
><P
>The explanation is simply that even in a rather unexciting Internet
backwater, at the far end of an unexceptional ADSL line there's still
an incredible amount of uncontrolled Windows traffic such as file
sharing and various types of searches trying to get to you.  The
Windows boxes on the inside probably weren't totally quiet either. At
any rate: put some sensible limit on what you log, or make
arrangements for sufficient disk space, somewhere.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./note.jpg"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>Log responsibly!</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>When you enable logging of network traffic, your system will start accumulating potentially sensitive data about your users and the network resources they access.  Storing traffic data may in turn trigger legal obligations.  The specific requirements (if any) will vary according to local legislation, make sure you check what requirements apply to you. </P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="SYSTAT-STATES"
></A
>Keeping an eye on things with systat</H1
><P
>If you are interested in seeing an instant snapshot of the traffic passing through
      your systems right now, the <SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/systat"
TARGET="_top"
>systat</A
>
      </SPAN
> program on OpenBSD offers several useful
views. One such view is the states view, which offers a live view of the state table. Here is a typical view:</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>   3 users    Load 2.38 2.34 2.25  (1-25 of 184)       Sun Nov 28 19:07:57 2010

PR    D SRC                  DEST                 STATE   AGE   EXP  PKTS BYTES  RATE  PEAK   AVG
tcp   I 192.168.103.84:51576 208.43.202.3:80       4:4  4984m 86369 12561 2199K     0   108     7
tcp   O 213.187.179.198:5157 208.43.202.3:80       4:4  4984m 86369 12561 2199K     0   108     7
tcp   I 192.168.103.254:5598 78.31.12.67:80        4:4  4570m 86373 22954 4781K     0    23    17
tcp   O 213.187.179.198:5598 78.31.12.67:80        4:4  4570m 86373 22954 4781K     0    23    17
tcp   I 10.168.103.15:3427   213.187.179.198:22    4:4  96162 86373  4784  705K     0    43     7
tcp   I 10.168.103.15:22198  128.237.157.136:6667  4:4  26629 86385  6743 1918K     0  1677    73
tcp   O 213.187.179.198:2219 128.237.157.136:6667  4:4  26629 86385  6743 1918K     0  1677    73
tcp   I 10.168.103.15:19492  203.27.221.42:6667    4:4  26592 86385  2635  216K     0    34     8
tcp   O 213.187.179.198:1949 203.27.221.42:6667    4:4  26592 86385  2635  216K     0    34     8
tcp   I 10.168.103.15:4169   209.250.145.51:6667   4:4  26590 86385  2883  260K     0    40    10
tcp   O 213.187.179.198:4169 209.250.145.51:6667   4:4  26590 86385  2883  260K     0    40    10
tcp   I 10.168.103.15:29582  198.3.160.3:6667      4:4  26543 86385  2931  224K     0    34     8
tcp   O 213.187.179.198:2958 198.3.160.3:6667      4:4  26543 86385  2931  224K     0    34     8
tcp   I 10.168.103.15:26952  130.133.4.11:119      4:4  26340 86260  1015  522K     0     0    20
tcp   O 213.187.179.198:2695 130.133.4.11:119      4:4  26340 86260  1015  522K     0     0    20
tcp   I 192.168.103.254:6329 192.168.103.84:9000   4:4  26289 86376 29407   21M     0  6197   838
tcp   O 192.168.103.1:53161  192.168.103.84:9000   4:4  26289 86376 29407   21M     0  6197   838
tcp   I 10.168.103.15:28623  129.240.64.10:6667    4:4  25984 86385  3927  359K     0    32    14
tcp   O 213.187.179.198:2862 129.240.64.10:6667    4:4  25984 86385  3927  359K     0    32    14
tcp   I 10.168.103.15:4436   213.187.179.198:22    4:4  14349 86381   978  223K     0    56    15
icmp  I 10.168.103.15:34372  213.187.179.198:8     0:0  11083    10 21716 1781K   168   168   164
tcp   I 10.168.103.15:35760  194.14.70.181:80      4:4  10596 75806   143  114K     0     0    11
tcp   O 213.187.179.198:3576 194.14.70.181:80      4:4  10596 75806   143  114K     0     0    11
tcp   I 192.168.103.84:52785 74.125.77.188:5228    4:4   7877 85731    53  4833     0     0     0
tcp   O 213.187.179.198:5278 74.125.77.188:5228    4:4   7877 85731    53  4833     0     0     0</SAMP
></PRE
><P
>Wider terminal windows offer more detail, and the OpenBSD version of <SPAN
CLASS="APPLICATION"
>systat</SPAN
> offers several other PF-related views.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="PFTOP"
></A
>Keeping an eye on things with pftop</H1
><P
>If you're running a system where the local
<SPAN
CLASS="APPLICATION"
>systat</SPAN
> does not offer PF related views and
you are interested in keeping an eye on what passes in to and out of
your network, Can Erkin Acar's <SPAN
CLASS="APPLICATION"
>pftop</SPAN
> is a
very useful tool.  The name is a strong hint at what it does -
<SPAN
CLASS="APPLICATION"
>pftop</SPAN
> shows a running snapshot of your
traffic in a format which is strongly inspired by
<SPAN
CLASS="APPLICATION"
>top</SPAN
>(1):</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>pfTop: Up State 1-21/67, View: default, Order: none, Cache: 10000       19:52:28

PR   DIR SRC                  DEST                 STATE   AGE   EXP  PKTS BYTES
tcp  Out 194.54.103.89:3847   216.193.211.2:25      9:9     28    67    29  3608
tcp  In  207.182.140.5:44870  127.0.0.1:8025        4:4     15 86400    30  1594
tcp  In  207.182.140.5:36469  127.0.0.1:8025       10:10   418    75   810 44675
tcp  In  194.54.107.19:51593  194.54.103.65:22      4:4    146 86395   158 37326
tcp  In  194.54.107.19:64926  194.54.103.65:22      4:4    193 86243   131 21186
tcp  In  194.54.103.76:3010   64.136.25.171:80      9:9    154    59    11  1570
tcp  In  194.54.103.76:3013   64.136.25.171:80      4:4      4 86397     6  1370
tcp  In  194.54.103.66:3847   216.193.211.2:25      9:9     28    67    29  3608
tcp  Out 194.54.103.76:3009   64.136.25.171:80      9:9    214     0     9  1490
tcp  Out 194.54.103.76:3010   64.136.25.171:80      4:4     64 86337     7  1410
udp  Out 194.54.107.18:41423  194.54.96.9:53        2:1     36     0     2   235
udp  In  194.54.107.19:58732  194.54.103.66:53      1:2     36     0     2   219
udp  In  194.54.107.19:54402  194.54.103.66:53      1:2     36     0     2   255
udp  In  194.54.107.19:54681  194.54.103.66:53      1:2     36     0     2   271</SAMP
></PRE
><P
>Your connections can be shown sorted by a number of different criteria,
among others by PF rule, volume, age and so on.</P
><P
>This program is not in the base system itself, probably because it is
possible to extract equivalent information using various
<SPAN
CLASS="APPLICATION"
>pfctl</SPAN
>
options. <SPAN
CLASS="APPLICATION"
>pftop</SPAN
> is however available as a
package, in ports on OpenBSD and FreeBSD both as
<TT
CLASS="FILENAME"
>sysutils/pftop</TT
>, on NetBSD via pkgsrc
as <TT
CLASS="FILENAME"
>sysutils/pftop</TT
>.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="BRIDGE"
></A
>Invisible gateway - bridge</H1
><P
>  A <I
CLASS="FIRSTTERM"
><A
HREF="http://man.openbsd.org/bridge"
TARGET="_top"
>bridge</A
>
  </I
> in our context is a machine with
two or more network interfaces, located in between the Internet and
one or more internal networks, and the network interfaces are not
assigned IP addresses.  If the machine in question runs OpenBSD 
or a similarly capable operating system, it is still able to filter 
and redirect traffic.  The advantage of such a setup is that attacking
the firewall itself is more difficult.  The disadvantage is that all
admin tasks must be performed at the firewall's console, unless you
configure a network interface which is reachable via a secured network 
of some kind, or even a serial console.</P
><P
>The exact method for configuring bridges differs in some details between 
the operating systems. Below is a short recipe for use on OpenBSD, which
for good measure blocks all non-Internet protocol traffic.  
<DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./warning.jpg"
HSPACE="5"
ALT="Warning"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Please note</I
></SPAN
> that this example is <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> a complete, working configuration.  You will need to study your local requirements and adapt the configuration accordingly.  As stated earlier in <A
HREF="#PREFACE"
>the Chapter called <I
>Before we start</I
></A
>, neither this example nor any other part of this document should be pasted into your configuration without modification.  Also see the <A
HREF="http://bsdly.blogspot.com/2011/01/i-will-not-mindlessly-paste-from-howtos.html"
TARGET="_top"
>I will not mindlessly paste from HOWTOs</A
> blog post on a related incident.</P
></TD
></TR
></TABLE
></DIV
>
Setting up a bridge with two interfaces:</P
><P
><TT
CLASS="FILENAME"
>/etc/hostname.ep0</TT
></P
><PRE
CLASS="PROGRAMLISTING"
>up</PRE
><P
><TT
CLASS="FILENAME"
>/etc/hostname.ep1</TT
></P
><PRE
CLASS="PROGRAMLISTING"
>up</PRE
><P
><TT
CLASS="FILENAME"
>/etc/hostname.bridge0</TT
> (on pre-OpenBSD 4.7 setups:<TT
CLASS="FILENAME"
>/etc/bridgename.bridge0</TT
>)</P
><PRE
CLASS="PROGRAMLISTING"
>  add ep0 add ep1 blocknonip ep0 blocknonip ep1 up</PRE
><P
><TT
CLASS="FILENAME"
>/etc/pf.conf</TT
></P
><PRE
CLASS="PROGRAMLISTING"
>ext_if = ep0
int_if  = ep1
interesting-traffic = { ... }
block all
pass quick on $ext_if all
pass log on $int_if from $int_if to any port $interesting-traffic \
     keep state</PRE
><P
>Significantly more complicated setups are possible.  Experienced
bridgers recommend picking one of the interfaces to perform all
filtering and redirection.  All packets pass through PF's view twice,
making for potentially extremely complicated rules.</P
><P
>In addition, on OpenBSD the <SPAN
CLASS="APPLICATION"
>ifconfig</SPAN
> command offers its own set of
filtering options in addition to other configuration options  (<SPAN
CLASS="APPLICATION"
>brconfig</SPAN
>'s functionality was merged into <SPAN
CLASS="APPLICATION"
>ifconfig</SPAN
> for OpenBSD 4.7). The 
bridge(4) and ifconfig(8) man pages offer further information.  A slightly more thorough treatment is available in <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
><A
HREF="http://nostarch.com/pf2.htm"
TARGET="_top"
>The Book of PF</A
></I
></SPAN
>, available from <A
HREF="http://nostarch.com/"
TARGET="_top"
>No Starch Press</A
>.</P
><P
>FreeBSD uses a slightly different set of commands to configure bridges,
while the NetBSD PF implementation supports bridging only with a slightly customized kernel<A
NAME="AEN1281"
HREF="#FTN.AEN1281"
><SPAN
CLASS="footnote"
>[20]</SPAN
></A
>
.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="ALTQINTRO"
></A
>Directing traffic with ALTQ</H1
><P
>ALTQ - short for ALTernate Queueing - is a very flexible mechanism for
directing network traffic which lived a life of its own before getting
integrated into PF.  Altq was another one of those things which were
integrated into PF because of the additional convenience it offered
when integrated.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./note.jpg"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>Note: OpenBSD traffic shaping uses a different, simpler syntax</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The new traffic shaping framework <A
HREF="http://bsdly.blogspot.com/2011/07/what-to-expect-in-openbsd-50-onwards.html"
TARGET="_top"
>hinted at</A
> by commits as far back as the development phase for OpenBSD 5.0 was finally introduced in OpenBSD 5.5 and from OpenBSD 5.6 it's the only traffic shaping option available. If you want a gentler introduction to the new traffic shaping system than what's offered by the official documentation, please see the relevant parts of <A
HREF="http://www.nostarch.com/pf3"
TARGET="_top"
>The Book of PF</A
> (3rd edition) or see the <A
HREF="http://home.nuug.no/~peter/pf/newest/"
TARGET="_top"
>slides</A
> 
matching my latest tutorial session.</P
></TD
></TR
></TABLE
></DIV
><P
>ALTQ uses the term <I
CLASS="FIRSTTERM"
>queue</I
> about the main traffic
control mechanisms. Queues are defined with a defined amount of bandwidth
or a specific part of available bandwidth, where a queue can be assigned 
subqueues of various types.</P
><P
>To complete the picture, you write filtering rules which assign
packets to specified queues or a selection of subqueues where packets
pass according to specified criteria.</P
><P
>Queues are created with one of several queue
<I
CLASS="FIRSTTERM"
>disciplines</I
>.  The default queue discipline
without ALTQ is FIFO (first, in first out).  </P
><P
>A slightly more interesting discipline is the class based discipline
(CBQ), which in practical terms means you define the queue's bandwidth
as a set amount of data per second, as a percentage or in units of
kilobits, megabits and so on, with an additional priority as an
option, or priority based (priq), where you assign priority only.</P
><P
>Priorities can be set at 0 to 7 for cbq queues, 0 to 15 for priq
queues, with a higher value assigning a higher priority and
preferential treatment. In addition, the hierarchical queue algorithm
"Hierarchical Fair Service Curve" or HFSC is available.</P
><P
>Briefly, a simplified syntax is</P
><PRE
CLASS="PROGRAMLISTING"
>altq on interface type [options ... ] main_queue { sub_q1, sub_q2 ..}
  queue sub_q1 [ options ... ]
  queue sub_q2 [ options ... ]
[...]
pass [ ... ] queue sub_q1
pass [ ... ] queue sub_q2</PRE
><P
>If you will be using these features in you own rule sets, you 
should under any circumstances read the <TT
CLASS="FILENAME"
>pf.conf</TT
> man page
and the PF user guide. These documents offer a very detailed and reasonably
well laid out explanation of the syntax and options.<A
NAME="AEN1304"
HREF="#FTN.AEN1304"
><SPAN
CLASS="footnote"
>[21]</SPAN
></A
>
<A
NAME="AEN1307"
HREF="#FTN.AEN1307"
><SPAN
CLASS="footnote"
>[22]</SPAN
></A
></P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="ALTQACKPRI"
>ALTQ - prioritizing by traffic type</A
></H2
><P
>Our first real example is lifted from Daniel Hartmeier's web.
Like quite a few of us, Daniel is on an asymmetric connection, and naturally
he wanted to get better bandwidth utilization. </P
><P
>One symptom in particular seemed to indicate that there was room for
improvement. Incoming traffic (downloads) apparently slowed down
outgoing traffic. </P
><P
>Analyzing the data indicated that the ACK packets for each data packet
transferred caused a disproportionately large slowdown, possibly due to
the FIFO (First In, First Out) queue discipline in effect on the outgoing
traffic.</P
><P
>A testable hypothesis formed - if the tiny, practically dataless ACK
packets were able to slip inbetween the larger data packets, this
would lead to a more efficient use of available bandwidth. The means
were two queues with different priorities. The relevant parts of the
rule set follows:</P
><PRE
CLASS="PROGRAMLISTING"
>ext_if="kue0"

altq on $ext_if priq bandwidth 100Kb queue { q_pri, q_def }
queue q_pri priority 7
queue q_def priority 1 priq(default)

pass out on $ext_if proto tcp from $ext_if to any flags S/SA \
        keep state queue (q_def, q_pri)

pass in  on $ext_if proto tcp from any to $ext_if flags S/SA \
        keep state queue (q_def, q_pri)</PRE
><P
>The result was indeed better performance. </P
><DIV
CLASS="SECTION"
><HR><H3
CLASS="SECTION"
><A
NAME="ALTQACKPRI.TOS"
>So why does this work?</A
></H3
><P
>So why does this work?<A
NAME="AEN1321"
HREF="#FTN.AEN1321"
><SPAN
CLASS="footnote"
>[23]</SPAN
></A
> The reason lies in how the ALTQ code treats
subqueues with different priorities.  Once a connection is assigned to
the main queue, ALTQ inspects each packet's type of service (ToS)
field.  ACK packets have the ToS Delay bit set to 'low', which
indicates that the sender wanted the speediest delivery possible.</P
><P
>When ALTQ sees a low delay packet and queues of differing priorities
are available, it will assign the packet to the higher priority queue.
This means that the ACK packets skip ahead of the lower priority queue
and are delivered more quickly, which in turn means that data packets
are serviced more quickly, too.</P
><P
>Daniel's article is available from his web site at <A
HREF="http://www.benzedrine.ch/ackpri.html"
TARGET="_top"
>http://www.benzedrine.ch/ackpri.html</A
>. Also see an <A
HREF="http://home.nuug.no/~peter/pf/newest/prio.html"
TARGET="_top"
>equivalent example</A
> using the new syntax.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H3
CLASS="SECTION"
><A
NAME="MATCHQUEUEASSIGN"
>Using a match Rule for Queue Assignment</A
></H3
><P
>Starting with OpenBSD 4.6, it is possible to assign traffic to queues using <KBD
CLASS="USERINPUT"
>match</KBD
> rules as well as <KBD
CLASS="USERINPUT"
>pass</KBD
> rules.  This makes it extremely easy to add an ALTQ regime to an existing rule set.  In order to apply the priority scheme we just presented to an existing rule set on OpenBSD 4.6 or newer, you would add teh <KBD
CLASS="USERINPUT"
>altq</KBD
> definition block at the top of the rule set, followed by the following rule:</P
><PRE
CLASS="SCREEN"
>match out on $ext_if from $int_if:network queue (q_def, q_pri)</PRE
><P
>If your gateway does NAT, it could also be useful to rewrite the <KBD
CLASS="USERINPUT"
>match</KBD
> rule that applies the <KBD
CLASS="USERINPUT"
>nat-to</KBD
> to do the queue assignment as well (simply tack on the queue assignment at the end).</P
></DIV
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="ALTQBYPCT"
>ALTQ - allocation by percentage</A
></H2
><P
>We move on to another example, which I for all practical purposes
swiped from the Swedish site unix.se.  The queues are set up on the
external interface.  This is probably the more common approach, since
the limitations on bandwidth are usually more severe on the external
interface. In principle, however, allocating queues and running
traffic shaping can be done on any network interface.  Here, the setup
includes a cbq queue for a total bandwidth of 640KB with six sub
queues.</P
><PRE
CLASS="PROGRAMLISTING"
>altq on $ext_if cbq bandwidth 640Kb queue { def, ftp, udp, http, \
         ssh, icmp }
queue def bandwidth 18% cbq(default borrow red)
queue ftp bandwidth 10% cbq(borrow red)
queue udp bandwidth 30% cbq(borrow red)
queue http bandwidth 20% cbq(borrow red)
queue ssh bandwidth 20% cbq(borrow red) { ssh_interactive, ssh_bulk }
          queue ssh_interactive priority 7 bandwidth 20%
          queue ssh_bulk priority 0 bandwidth 80%
queue icmp bandwidth 2% cbq</PRE
><P
>We see the subqueue def with 18 percent of the bandwidth is designated 
as the default queue, that is any traffic not explicitly assigned to some 
other queue ends up here. The borrow and red keywords mean that the queue
may 'borrow' bandwidth from its parent queue, while the system attempts to 
avoid congestion by applying the RED (Random Early Detection) algorithm. 
The other queues follow more or less the same pattern, up to the
subqueue ssh, which itself has two subqueues with separate priorities.</P
><P
>In the ssh queue, again we see a variation of the ACK priority via
subqueues scheme: Bulk SSH transfers, typically SCP file transfers,
get transmitted with a ToS indicating normal delay, while interactive
SSH traffic has the low delay bit set and skips ahead of the bulk
transfers.</P
><P
>This scheme probably also helps the speed of SCP file transfers, since
the SCP ACK packets will be assigned to the higher priority subqueue.</P
><P
>Finally, the pass rules which show which traffic gets assigned to the queues,
and their criteria:</P
><PRE
CLASS="PROGRAMLISTING"
>pass log quick on $ext_if proto tcp from any to any port 22 flags S/SA \ 
    keep state queue (ssh_bulk, ssh_interactive)
pass in quick on $ext_if proto tcp from any to any port 20 flags S/SA  \
    keep state queue ftp
pass in quick on $ext_if proto tcp from any to any port 80 flags S/SA \
    keep state queue http
pass out on $ext_if proto udp all keep state queue udp
pass out on $ext_if proto icmp all keep state queue icmp</PRE
><P
>We can reasonably assume that this allocation meets the site's needs.</P
><P
>The full description can be found at the Unix.se site as <A
HREF="http://unix.se/Brandv%E4gg_med_OpenBSD"
TARGET="_top"
>http://unix.se/Brandv%E4gg_med_OpenBSD</A
></P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="ALTQSMTP"
>ALTQ - handling unwanted traffic</A
></H2
><P
>&#13;Our last altq example is one which surfaced around the time of one of
the many spam or virus storms we've seen during the last few years.
It's fairly common knowledge that the machines causing these bursts
of email are practically all Windows machines. PF has a fairly reliable
operating system fingerprinting mechanism which detects the operating
system at the other end of a network connection. One OpenBSD user got
sufficiently tired of all this meaningless traffic, and posted some
selected bits of his <TT
CLASS="FILENAME"
>pf.conf</TT
> on his blog:</P
><PRE
CLASS="PROGRAMLISTING"
>altq on $ext_if cbq queue { q_default q_web q_mail }

   queue q_default cbq(default)
   queue q_web (...) 

    ## all mail limited to 1Mb/sec
    queue q_mail bandwidth 1Mb { q_mail_windows }
    ## windows mail limited to 56Kb/sec
    queue q_mail_windows bandwidth 56Kb

    pass in quick proto tcp from any os "Windows" to $ext_if port 25 \
            keep state queue q_mail_windows
    pass in quick proto tcp from any to $ext_if port 25 label "smtp" \
            keep state queue q_mail</PRE
><PRE
CLASS="SCREEN"
>" I can't believe I didn't see this earlier. Oh, how sweet. ... 
  Already a huge difference in my load. Bwa ha ha. "</PRE
><P
>Randal L. Schwartz, 29. January 2004, <A
HREF="http://use.perl.org/~merlyn/journal/17094"
TARGET="_top"
>http://use.perl.org/~merlyn/journal/17094</A
></P
><P
>Here all email traffic is assigned one megabit worth of bandwidth, while
email traffic originating at Windows hosts get to share a subqueue of 
56 Kbit total. No wonder the total load went down and the blog post ends
with what must be an evil chuckle.</P
><P
>I must confess this is something I've wanted very much to do myself, but
I've never dared.  A few too many of our customers have for their own
reasons chosen to run their mail service on Windows, and we do like to
receive most of their mail. In a little while, we'll have a look at a
different PF approach which may have achieved much of the same effect.</P
><P
>A somewhat more thorough treatment of ALTQ (including a basic HFSC traffic shaper configuration) can be found in <A
HREF="http://www.nostarch.com/pf3"
TARGET="_top"
>The Book of PF</A
>.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CARP"
></A
>CARP and pfsync</H1
><P
>CARP and pfsync were two of the main new items in OpenBSD 3.5. CARP is
short for Common Address Redundancy Protocol. The protocol was
developed as a non patent encumbered alternative to VRRP (Virtual
Router Redundancy Protocol, RFC 2281, RFC 3768), which was quite far
along the track to becoming an IETF sanctioned standard, even though
possible patent issued has not been resolved. The patents involved
are held by Cisco, IBM and Nokia.</P
><P
>Both protocols are intended to ensure redundancy for essential network
features, with automatic failover.</P
><P
>CARP is based on setting up a group of machines as one 'master' and
one of more redundant 'slaves', all of which are equipped to handle
a common IP address.  If the master goes down, one of the slaves will
inherit the IP address, and if the synchronization has been properly
handled, active connections will be handed over. The handover may
be authenticated using cryptographic keys.</P
><P
>One of the main purposes of CARP is to ensure that the network will
keep functioning as usual even when a firewall or other service goes
down due to errors or planned maintenance activities such as upgrades.</P
><P
>In the case of PF firewalls, pfsync can handle the synchronization.
pfsync is a type of virtual network interface specially designed to
synchronize state information between PF firewalls.  pfsync interfaces
are assigned to physical interfaces with ifconfig.  On networks where
uptime requirements are strict enough to dictate automatic failover,
the number of simultaneous network connections is likely to be large
enough that it will make sense to assign the pfsync network its own
physical network.</P
><P
>This topic is one of those that feature in the advanced parts of my
tutorials at conferences and other venues, plus of course in <A
HREF="http://www.nostarch.com/pf3"
TARGET="_top"
>The Book of PF</A
>.
The best freely available pfsync and CARP references are the OpenBSD
FAQ, the man pages and Ryan McBride's overview article at <A
HREF="http://www.countersiege.com/doc/pfsync-carp/"
TARGET="_top"
>http://www.countersiege.com/doc/pfsync-carp/</A
>.  Also see <A
HREF="#REFERENCES"
>the Chapter called <I
>References</I
></A
> at the end of this document.</P
><P
>A somewhat more thorough treatment of CARP and pfsync (with both failover and load balancing configurations) can be found in <A
HREF="https://www.nostarch.com/pf3"
TARGET="_top"
>The Book of PF</A
>.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="WIRELESS.SIMPLE"
></A
>Wireless networks made simple</H1
><P
>It is rather tempting to say that on BSD, and on OpenBSD in particular,
there's no need to 'make wireless networking simple', because it
already is.  Getting a wireless network running is basically not very
different from getting a wired one up and running, but then of course
there are some issues which turn up simply because we are dealing with
radio waves and not wires. We will look briefly at some of the issues
before moving on to the practical steps involved in creating a usable setup.</P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="WIFIBACKGROUND"
>A little IEEE 802.11 background</A
></H2
><P
>Moving to wireless networks provides an opportunity to view security
at various level in the networking stack from a new perspective.  We
look briefly at two of the basic IEEE 802.11 security mechanisms
below.</P
><P
>It goes almost without saying that you will need further security
measures, such as SSH or SSL encryption, to maintain any significant
level of confidentiality for your data stream.</P
><DIV
CLASS="SECTION"
><HR><H3
CLASS="SECTION"
><A
NAME="WEP"
>WEP (Wired Equivalent Privacy)</A
></H3
><P
>One consequence of using radio waves instead of wires is that it is
comparatively easy for outsiders to capture your data in transit.  The
designers of the 802.11 family of wireless network standards seem to
have been aware of this fact, and came up with a solution which they
marketed under the name <I
CLASS="FIRSTTERM"
>Wired Equivalent
Privacy</I
>, or <I
CLASS="FIRSTTERM"
>WEP</I
>.  </P
><P
>WEP is a link level encryption scheme which is considered a pretty
primitive homebrew among cryptography professionals.  It was no great
surprise that WEP encryption was reverse-engineered and cracked within
a few months after the first products were released.  Even though you
can download tools for free to descramble WEP encoded traffic in a
matter of minutes, for a variety of reasons it is still widely
supported and used.  You should consider network traffic protected
only by WEP to be only marginally more secure than data broadcast in
the clear.  Then again, the token effort needed to crack into a WEP
network may be sufficient to deter lazy and unsophisticated attackers.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H3
CLASS="SECTION"
><A
NAME="WPA"
>WPA (WiFi Protected Access)</A
></H3
><P
>It dawned fairly quickly on the 802.11 designers that their Wired
Equivalent Privacy system was not quite what it was cracked up to be,
and they came up with a revised and slightly more comprehensive
solution which was dubbed <I
CLASS="FIRSTTERM"
>WiFi Protected
Access</I
>, or <I
CLASS="FIRSTTERM"
>WPA</I
>.</P
><P
>WPA looks better than WEP, at least on paper, but the specification is
complicated enough that it is not nearly as widely supported or
implemented as its designers intended, but support finally arrived in OpenBSD 4.4.  In addition WPA has also
attracted its share of criticism over design issues and bugs.
Combined with the familiar issues of access to documentation and
hardware, free software support varies.  If your project specification
includes WPA, look carefully at your operating system and driver
documentation.</P
></DIV
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="WIRELESS.SIMPLE.SETUP"
>Setting up a simple wireless network</A
></H2
><P
>The first part is to make sure you have a supported card and check
your <SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/dmesg"
TARGET="_top"
>dmesg</A
></SPAN
> output to see that the driver loads and initializes the
card properly<A
NAME="AEN1398"
HREF="#FTN.AEN1398"
><SPAN
CLASS="footnote"
>[24]</SPAN
></A
> With a successfully
configured card you should see something like</P
><PRE
CLASS="SCREEN"
>ath0 at pci1 dev 4 function 0 "Atheros AR5212" rev 0x01: irq 11
ath0: AR5212 5.6 phy 4.1 rf5111 1.7 rf2111 2.3, ETSI1W, address 
00:0d:88:c8:a7:c4</PRE
><P
>Next, you need to configure the interface for TCP/IP. On OpenBSD, this 
means an <TT
CLASS="FILENAME"
>/etc/hostname.ath0</TT
> roughly like this:</P
><PRE
CLASS="PROGRAMLISTING"
>up media autoselect mediaopt hostap mode 11b chan 6 nwid unwiredbsd \
 nwkey 0x1deadbeef9
inet 10.168.103.1</PRE
><P
>Note that the configuration is divided over two lines.  The first line
generates an ifconfig command which sets up the interface with the
correct parameters for the physical wireless network, the second
command, which gets executed only after the first one completes, sets
the IP address. Note that we set the channel explicitly, and we enable
a weak WEP encryption by setting the <KBD
CLASS="USERINPUT"
>nwkey</KBD
> parameter.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./note.jpg"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>From OpenBSD 4.4 onwards, we have WPA, config simplified in OpenBSD 4.9</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>From OpenBSD 4.4 onwards, WPA is available.  To handle WPA keys we used <SPAN
CLASS="APPLICATION"
>wpa-psk</SPAN
>, either from the command line to generate a pasteable key:</P
><PRE
CLASS="SCREEN"
>$ wpa-psk unwiredbsd mylongpassphrase
0x7579c38e59faaa3b64bd8372e94f74fe7ae2e4e91af154c956a9bfd0240ac9d0</PRE
><P
>or directly in your network configuration file. Here is the configuration for a WPA access point, OpenBSD 4.4 style:</P
><PRE
CLASS="PROGRAMLISTING"
>up media autoselect mediaopt hostap mode 11b chan 6 nwid unwiredbsd \
 wpa wpapsk $(wpa-psk unwiredbsd mylongpassphase)</PRE
><P
>In OpenBSD 4.9, the WPA key functionality was merged into <SPAN
CLASS="APPLICATION"
>ifconfig</SPAN
>, and the configuration syntax was simplified. The WPA access point configuration in the OpenBSD 4.9 (and newer) style is:</P
><PRE
CLASS="PROGRAMLISTING"
>up media autoselect mediaopt hostap mode 11b chan 6 nwid unwiredbsd \
 wpakey mylongpassphase</PRE
><P
>and you would need to set up IP addresses and likely DHCP too, of course.</P
></TD
></TR
></TABLE
></DIV
><P
>On FreeBSD you would need to put those lines in your
<TT
CLASS="FILENAME"
>/etc/start_if.ath0</TT
>, and substitute your interface
name for <KBD
CLASS="USERINPUT"
>ath0</KBD
> if required</P
><P
>Then you most likely want to set up <SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/dhcpd"
TARGET="_top"
>dhcpd</A
></SPAN
> to serve addresses and
other relevant network information to clients. Your clients would need
an <TT
CLASS="FILENAME"
>/etc/hostname.ath0</TT
> configuration of </P
><PRE
CLASS="PROGRAMLISTING"
>up media autoselect mode 11b chan 6 nwid unwiredbsd nwkey 0x1deadbeef9
dhcp</PRE
><P
>For a setup with WPA and pre-shared keys corresponding to the access point earlier, you would need something like</P
><PRE
CLASS="PROGRAMLISTING"
>up media autoselect mode 11b chan 6 nwid unwiredbsd \ 
wpa wpapsk $(wpa-psk unwiredbsd mylongpassphase)</PRE
><P
>instead. <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note</I
></SPAN
> that the details of setting up WPA for FreeBSD differs somewhat.</P
><P
>and again on FreeBSD, you would need to put those
lines in your <TT
CLASS="FILENAME"
>/etc/start_if.ath0</TT
>, and substitute
your interface name for <KBD
CLASS="USERINPUT"
>ath0</KBD
> here if required.  </P
><P
>Assuming your gateway does NAT, you will want to set up NAT for the
wireless network as well, by making some small changes to your
<TT
CLASS="FILENAME"
>/etc/pf.conf</TT
>:</P
><PRE
CLASS="PROGRAMLISTING"
>air_if = "ath0"</PRE
><P
>and </P
><PRE
CLASS="PROGRAMLISTING"
>nat on $ext_if from $air_if:network to any -&#62; ($ext_if) static-port</PRE
><P
>You will need a similar near duplicate line for your ftp-proxy config,
and include <KBD
CLASS="USERINPUT"
>$air_if</KBD
> in your pass rules.</P
><P
>That's all there is to it. This configuration gives you a functional
BSD access point, with at least token security via WEP encryption, or WPA if your setup includes OpenBSD.</P
><P
>A somewhat more thorough treatment of wireless networks, including setup tips for newer FreeBSD configurations, can be found in <A
HREF="http://www.nostarch.com/pf3"
TARGET="_top"
>The Book of PF</A
>.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="VEGARD.AUTHPF"
></A
>An open, yet tightly guarded wireless network with <SPAN
CLASS="APPLICATION"
>authpf</SPAN
></H1
><P
>As always, there are other ways to configure the security of your
wireless network than the one we have just seen.  What little
protection WEP encryption offers, security professionals tend to agree
is barely enough to signal to an attacker that you do not intend to
let all and sundry use your network resources.</P
><P
>A different approach appeared one day in my mail as a message from my
friend Vegard Engen, who told me he had been setting up
<SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/authpf"
TARGET="_top"
>authpf</A
></SPAN
>.  <SPAN
CLASS="APPLICATION"
>authpf</SPAN
>
is a user shell which lets you load PF rules on a per user basis,
effectively deciding which user gets to do what.  </P
><P
>To use <SPAN
CLASS="APPLICATION"
>authpf</SPAN
>, you create users with the
<SPAN
CLASS="APPLICATION"
>authpf</SPAN
> program as their shell.  In order to
get network access, the user logs in to the gateway using
<SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/ssh"
TARGET="_top"
>ssh</A
></SPAN
>.  Once the user successfully completes
<SPAN
CLASS="APPLICATION"
>ssh</SPAN
> authentication,
<SPAN
CLASS="APPLICATION"
>authpf</SPAN
> loads the rules you have defined for
the user or the relevant class of users. </P
><P
>These rules, which apply to the IP address which the user logged in
from, stay loaded and in force for as long as the user stays logged in
via the <SPAN
CLASS="APPLICATION"
>ssh</SPAN
> connection.  Once the
connection is terminated, the rules are unloaded, and in most
scenarios all non-<SPAN
CLASS="APPLICATION"
>ssh</SPAN
> traffic from the
user's IP address is denied.  With a reasonable setup, only traffic
originated by authenticated users will be let through.</P
><P
>Vegard's annotated config follows below.  His wireless network is
configured without WEP encryption, preferring to handle the security
side of things via PF and <SPAN
CLASS="APPLICATION"
>authpf</SPAN
>:</P
><P
>Start with creating an empty <TT
CLASS="FILENAME"
>/etc/authpf/authpf.conf</TT
>. 
It needs to be there for <SPAN
CLASS="APPLICATION"
>authpf</SPAN
> to work, but 
doesn't actually need any content.</P
><P
>The other relevant bits of <TT
CLASS="FILENAME"
>/etc/pf.conf</TT
> follow. First, interface macros:</P
><PRE
CLASS="PROGRAMLISTING"
>int_if="sis1"
ext_if="sis0"
wi_if = "wi0"</PRE
><P
>The use of this address will become apparent later:</P
><PRE
CLASS="PROGRAMLISTING"
>auth_web="192.168.27.20"</PRE
><P
>The traditional authpf table</P
><PRE
CLASS="PROGRAMLISTING"
>table &lt;authpf_users&gt; persist </PRE
><P
>We could put the NAT part in <TT
CLASS="FILENAME"
>authpf.rules</TT
>, but keeping it in the main
<TT
CLASS="FILENAME"
>pf.conf</TT
> doesn't hurt:</P
><PRE
CLASS="PROGRAMLISTING"
>match out on $ext_if from $int_if:network nat-to ($ext_if)</PRE
><P
>or in pre-OpenBSD 4.7 syntax:</P
><PRE
CLASS="PROGRAMLISTING"
>nat on $ext_if from $wi_if:network to any -&#62; ($ext_if)</PRE
><P
>Redirects to let traffic reach servers on the internal net. These
could be put in <TT
CLASS="FILENAME"
>authpf.rules</TT
> too, but since they
do not actually provide access without pass rules, keeping them here
won't hurt anything.</P
><PRE
CLASS="PROGRAMLISTING"
>match in on $wi_if proto tcp from any to $myaddr port $tcp_in rdr-to $server
match in on $wi_if proto udp from any to $myaddr port $udp_in rdr-to $server</PRE
><P
>or in pre-OpenBSD 4.7 syntax:</P
><PRE
CLASS="PROGRAMLISTING"
>rdr on $wi_if proto tcp from any to $myaddr port $tcp_in -&#62; $server
rdr on $wi_if proto udp from any to $myaddr port $udp_in -&#62; $server</PRE
><P
>The next redirect sends all web traffic from non authenticated users
to port 80 on <KBD
CLASS="USERINPUT"
>$auth_web</KBD
>.  In Vegard's setup,
this is a web server which displays contact info for people who
stumble onto the wireless net.  In a commercial setting, this would be
where you would put something which could handle credit cards and
create users.</P
><PRE
CLASS="PROGRAMLISTING"
>match in on on $wi_if proto tcp from ! &lt;authpf_users&gt; port 80 rdr-to $auth_web</PRE
><P
>or in pre-OpenBSD 4.7 syntax:</P
><PRE
CLASS="PROGRAMLISTING"
>rdr on $wi_if proto tcp from ! &lt;authpf_users&gt; to any \
 port 80 -&#62; $auth_web</PRE
><P
>Also make sure you have the <KBD
CLASS="USERINPUT"
>authpf</KBD
> anchor:</P
><PRE
CLASS="PROGRAMLISTING"
>anchor "authpf/*"</PRE
><P
>in pre-OpenBSD 4.7 PF, you need separate anchors in order to activate nat, binat or redirects in authpf:</P
><PRE
CLASS="PROGRAMLISTING"
>nat-anchor "authpf/*"
binat-anchor "authpf/*"
rdr-anchor "authpf/*"</PRE
><P
>On to the filtering rules, we start with a sensible default</P
><PRE
CLASS="PROGRAMLISTING"
>block all</PRE
><P
>Other global, user independent rules would go here. Next for the
authpf anchor, we make sure non-authenticated users connecting to the
wireless interface get redirected to <KBD
CLASS="USERINPUT"
>$auth_web</KBD
></P
><PRE
CLASS="PROGRAMLISTING"
>anchor "authpf/*" in on wi0

pass in on $wi_if inet proto tcp from any to $auth_web \
 port 80 keep state</PRE
><P
>There are three things we want anyway on the wireless interface:
Name service (DNS), DHCP and SSH in to the gateway.  Three rules
do the trick</P
><PRE
CLASS="PROGRAMLISTING"
>pass in on $wi_if inet proto udp from any port 53 keep state

pass in on $wi_if inet proto udp from any to $wi_if port 67

pass in on $wi_if inet proto tcp from any to $wi_if \
 port 22 keep state</PRE
><P
>Next up, the we define the rules which get loaded for all users who log in with
their shell set to <TT
CLASS="FILENAME"
>/usr/sbin/authpf</TT
>. These rules go in 
<TT
CLASS="FILENAME"
>/etc/authpf/authpf.rules</TT
>,</P
><PRE
CLASS="PROGRAMLISTING"
>int_if = "sis1"
ext_if = "sis0"
wi_if = "wi0"
server = "192.168.27.15"
myaddr = "213.187.n.m"

# Services which live on the internal network 
# and need to be accessible
tcp_services = "{ 22, 25, 53, 80, 110, 113, 995 }"
udp_services = "{ 53 }"
tcp_in = " { 22, 25, 53, 80, 993, 2317, pop3}"
udp_in = "{ 53 }"

# Pass traffic to elsewhere, that is the outside world
pass in on $wi_if inet from &lt;authpf_users&gt; to ! $int_if:network \
   keep state

# Let authenticated users use services on 
# the internal network.

pass in on $wi_if inet proto tcp from &lt;authpf_users&gt; to $server \
  port $tcp_in keep state
pass in on $wi_if inet proto udp from &lt;authpf_users&gt; to $server \
  port $udp_in keep state

# Also pass to external address. This means you can access 
# internal services on external addresses.

pass in on $wi_if inet proto tcp from &lt;authpf_users&gt; to $myaddr \
    port $tcp_in keep state
pass in on $wi_if inet proto udp from &lt;authpf_users&gt; to $myaddr \
    port $udp_in keep state</PRE
><P
>At this point we have an open net where anybody can connect and get an
IP address from DHCP.  All HTTP requests from non-authenticated users
get redirected to port 80 on 192.168.27.20, which is a server on the
internal net where all requests are answered with the same page, which
displays contact info in case you want to be registered and be allowed
to use the net.</P
><P
>You are allowed to ssh in to the gateway. Users with valid user IDs
and passwords get rule sets with appropriate pass rules loaded for
their assigned IP address. </P
><P
>We can fine tune this even more by making
user specific rules in <TT
CLASS="FILENAME"
>/etc/authpf/users/$user/authpf.rules</TT
>. Per user
rules can use the $user_ip macro for the user's IP address. For
example, if I want to give myself unlimited access, create the
following <TT
CLASS="FILENAME"
>/etc/authpf/users/vegard/authpf.rules</TT
>:</P
><PRE
CLASS="PROGRAMLISTING"
>wi_if="wi0"
pass in on $wi_if from $user_ip to any keep state</PRE
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="BRUTEFORCE"
></A
>Turning away the brutes</H1
><P
>If you run a Secure Shell login service anywhere which is accessible
from the Internet, I'm sure you've seen things like these in your
authentication logs:</P
><PRE
CLASS="PROGRAMLISTING"
>Sep 26 03:12:34 skapet sshd[25771]: Failed password for root from 
200.72.41.31 port 40992 ssh2
Sep 26 03:12:34 skapet sshd[5279]: Failed password for root from 
200.72.41.31 port 40992 ssh2
Sep 26 03:12:35 skapet sshd[5279]: Received disconnect from 
200.72.41.31: 11: Bye Bye
Sep 26 03:12:44 skapet sshd[29635]: Invalid user admin from 
200.72.41.31
Sep 26 03:12:44 skapet sshd[24703]: input_userauth_request: 
invalid user admin
Sep 26 03:12:44 skapet sshd[24703]: Failed password for invalid user 
admin from 200.72.41.31 port 41484 ssh2
Sep 26 03:12:44 skapet sshd[29635]: Failed password for invalid user 
admin from 200.72.41.31 port 41484 ssh2
Sep 26 03:12:45 skapet sshd[24703]: Connection closed by 200.72.41.31
Sep 26 03:13:10 skapet sshd[11459]: Failed password for root from 
200.72.41.31 port 43344 ssh2
Sep 26 03:13:10 skapet sshd[7635]: Failed password for root from 
200.72.41.31 port 43344 ssh2
Sep 26 03:13:10 skapet sshd[11459]: Received disconnect from 
200.72.41.31: 11: Bye Bye
Sep 26 03:13:15 skapet sshd[31357]: Invalid user admin from 200.72.41.31
Sep 26 03:13:15 skapet sshd[10543]: input_userauth_request: invalid 
user admin
Sep 26 03:13:15 skapet sshd[10543]: Failed password for invalid user 
admin from 200.72.41.31 port 43811 ssh2
Sep 26 03:13:15 skapet sshd[31357]: Failed password for invalid user 
admin from 200.72.41.31 port 43811 ssh2
Sep 26 03:13:15 skapet sshd[10543]: Received disconnect from 
200.72.41.31: 11: Bye Bye
Sep 26 03:13:25 skapet sshd[6526]: Connection closed by 200.72.41.31</PRE
><P
>It gets repetitive after that.  This is what a brute force attack
looks like.  Essentially somebody, or more likely, a cracked computer
somewhere, is trying by brute force to find a combination of user name
and password which will let them into your system.</P
><P
>The simplest response would be to write a <TT
CLASS="FILENAME"
>pf.conf</TT
>
rule which blocks all access.  This leads to another class of
problems, including what you do in order to let people with legitimate
business on your system access it anyway.  You might consider moving
the service to some other port, but then again, the ones flooding you
on port 22 would probably be able to scan their way to port 22222 for
a repeat performance.<A
NAME="AEN1522"
HREF="#FTN.AEN1522"
><SPAN
CLASS="footnote"
>[25]</SPAN
></A
></P
><P
>Since OpenBSD 3.7<A
NAME="AEN1526"
HREF="#FTN.AEN1526"
><SPAN
CLASS="footnote"
>[26]</SPAN
></A
>, PF has offered a slightly more elegant
solution.  You can write your pass rules so they maintain certain
limits on what connecting hosts can do.  For good measure, you can
banish violators to a table of addresses which you deny some or all
access.  You can even choose to drop all existing connections from
machines which overreach your limits, if you like.  Here's how it's
done:</P
><P
>Now first set up the table. In your tables section, add</P
><PRE
CLASS="PROGRAMLISTING"
>table &lt;bruteforce&gt; persist</PRE
><P
>Then somewhere fairly early in your rule set you set up to block from
the bruteforcers</P
><PRE
CLASS="PROGRAMLISTING"
>block quick from &lt;bruteforce&gt;</PRE
><P
>And finally, your pass rule.</P
><PRE
CLASS="PROGRAMLISTING"
>pass inet proto tcp from any to $localnet port $tcp_services \
        flags S/SA keep state \
	(max-src-conn 100, max-src-conn-rate 15/5, \
         overload &lt;bruteforce&gt; flush global)</PRE
><P
>This is rather similar to what we've seen before, isn't it? In fact,
the first part is identical to the one we constructed earlier. The
part in brackets is the new stuff which will ease your network load
even further.</P
><P
><I
CLASS="FIRSTTERM"
>max-src-conn</I
> is the number of simultaneous
connections you allow from one host.  In this example, I've set it at
100, in your setup you may want a slightly higher or lower
value.</P
><P
><I
CLASS="FIRSTTERM"
>max-src-conn-rate</I
> is the rate of new
connections allowed from any single host, here 15 connections per 5
seconds. Again, you are the one to judge what suits your setup.</P
><P
><I
CLASS="FIRSTTERM"
>overload</I
>
<SAMP
CLASS="COMPUTEROUTPUT"
>&lt;bruteforce&gt;</SAMP
> means that any
host which exceeds these limits gets its address added to the table
<SAMP
CLASS="COMPUTEROUTPUT"
>bruteforce</SAMP
>. Our rule set blocks all
traffic from addresses in the bruteforce table.</P
><P
>finally, <I
CLASS="FIRSTTERM"
>flush</I
> <I
CLASS="FIRSTTERM"
>global</I
>
says that when a host reaches the limit, that host's connections will
be terminated (flushed). The global part says that for good measure,
this applies to connections which match other pass rules too.</P
><P
>The effect is dramatic.  My bruteforcers more often than not end up
with <SAMP
CLASS="COMPUTEROUTPUT"
>&quot;Fatal: timeout before authentication&quot;</SAMP
> 
messages, which is exactly what we want.</P
><P
>Once again, please keep in mind that this example rule is intended mainly as an
illustration.  It is not unlikely that your network's needs are better served by
rather different rules or combinations of rules.</P
><P
>If, for example, you want to allow a generous number of connections in
general, but would like to be a little more tight fisted when it comes
to <SPAN
CLASS="APPLICATION"
>ssh</SPAN
>, you could supplement the rule above
with something like the one below, early on in your rule set:</P
><PRE
CLASS="PROGRAMLISTING"
>pass quick proto tcp from any to any port ssh \
        flags S/SA keep state \
        (max-src-conn 15, max-src-conn-rate 5/3, \
        overload &lt;bruteforce&gt; flush global)</PRE
><P
>Despite what it likely says in your <TT
CLASS="FILENAME"
>/etc/services</TT
>
file, existing <SPAN
CLASS="APPLICATION"
>ssh</SPAN
> implementations use TCP
only, as specified in RFC4253.  You should be able to find the set of
parameters which is just right for your situation by reading the
relevant man pages and the <A
HREF="http://www.openbsd.org/faq/pf/"
TARGET="_top"
>PF User Guide</A
>, and
perhaps a bit of experimentation.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./note.jpg"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>You may not need to <KBD
CLASS="USERINPUT"
>block</KBD
> all of your <KBD
CLASS="USERINPUT"
>overload</KBD
>ers</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>It is probably worth noting at this point that the
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>overload</I
></SPAN
> mechanism is a general technique which
does not have to apply exclusively to the <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ssh</I
></SPAN
>
service, and it is not necessarily always optimal to block all traffic
from offenders entirely.  </P
><P
>You could for example use an overload rule to protect a mail service
or a web service, and you could use the overload table in a rule to
assign offenders to a queue with a minimal bandwidth allocation (see
<A
HREF="#ALTQSMTP"
>the Section called <I
>ALTQ - handling unwanted traffic</I
> in the Chapter called <I
>Directing traffic with ALTQ</I
></A
>) or, in the web case, to redirect to a
specific web page (much like in the <SPAN
CLASS="APPLICATION"
>authpf</SPAN
>
example in <A
HREF="#VEGARD.AUTHPF"
>the Chapter called <I
>An open, yet tightly guarded wireless network with <SPAN
CLASS="APPLICATION"
>authpf</SPAN
></I
></A
>).</P
></TD
></TR
></TABLE
></DIV
><P
>It is worth noting that this technique does not stop the slow bruteforcers commonly known as <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
><A
HREF="http://home.nuug.no/~peter/hailmary2013/"
TARGET="_top"
>The Hail Mary Cloud</A
></I
></SPAN
> (also see the article <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
><A
HREF="http://bsdly.blogspot.com/2013/10/the-hail-mary-cloud-and-lessons-learned.html"
TARGET="_top"
>The Hail Mary Cloud And The Lessons Learned</A
></I
></SPAN
>, which likely was (or is) a deliberate attempt at avoiding this kind of measure. See the referenced overview article for more material.</P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="EXPIRE"
>expiring table entries with <SPAN
CLASS="APPLICATION"
>pfctl</SPAN
></A
></H2
><P
>At this point, we have tables which will be filled by our
<KBD
CLASS="USERINPUT"
>overload</KBD
> rules, and since we could reasonably
expect our gateways to have months of uptime, the tables will grow
incrementally, taking up more memory as time goes by.</P
><P
>You could also find that an IP address you blocked last week due to a
brute force attack was in fact a dynamically assigned one, which is
now assigned to a different ISP customer who has a legitimate reason
to try communicating with hosts in your network.</P
><P
>Situations like these were what caused Henning Brauer to add to <SPAN
CLASS="APPLICATION"
>pfctl</SPAN
> 
the ability to expire table entries not referenced in a specified
number of seconds (in OpenBSD 4.1).  For example, the command</P
><PRE
CLASS="SCREEN"
># pfctl -t bruteforce -T expire 86400</PRE
><P
>will remove <SAMP
CLASS="COMPUTEROUTPUT"
>&lt;bruteforce&gt;</SAMP
> table
entries which have not been referenced for 86400 seconds.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="EXPIRETABLE"
>Using <SPAN
CLASS="APPLICATION"
>expiretable</SPAN
> to tidy your tables</A
></H2
><P
>Before <SPAN
CLASS="APPLICATION"
>pfctl</SPAN
> acquired the ability to expire
table entries, Henrik Gustafsson had written
<SPAN
CLASS="APPLICATION"
>expiretable</SPAN
>, which removes table entries
which have not been accessed for a specified period of time.</P
><P
>One useful example is to use the
<SPAN
CLASS="APPLICATION"
>expiretable</SPAN
> program as a way of removing
outdated <KBD
CLASS="USERINPUT"
>&lt;bruteforce&gt;</KBD
> table entries.</P
><P
>You could for example let <SPAN
CLASS="APPLICATION"
>expiretable</SPAN
>
remove <KBD
CLASS="USERINPUT"
>&lt;bruteforce&gt;</KBD
> table entries older
than 24 hours by adding an entry containing the following 
to your <TT
CLASS="FILENAME"
>/etc/rc.local</TT
> file:</P
><PRE
CLASS="PROGRAMLISTING"
>/usr/local/sbin/expiretable -v -d -t 24h bruteforce</PRE
><P
><SPAN
CLASS="APPLICATION"
>expiretable</SPAN
> was quickly added to the ports
tree on FreeBSD and OpenBSD<A
NAME="AEN1599"
HREF="#FTN.AEN1599"
><SPAN
CLASS="footnote"
>[27]</SPAN
></A
>.</P
><P
>If <SPAN
CLASS="APPLICATION"
>expiretable</SPAN
> is not available via your
package system, you can download it from Henrik's site at <A
HREF="http://expiretable.fnord.se/"
TARGET="_top"
>http://expiretable.fnord.se/</A
></P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="SPAMD"
></A
>Giving spammers a hard time</H1
><P
>At this point we've covered quite some ground, and I'm more than happy
to present something really useful: PF as a means to make spammers'
lives harder.  Based on our recent exposure to PF rulesets,
understanding the following <TT
CLASS="FILENAME"
>/etc/pf.conf</TT
> parts
should be straightforward:</P
><PRE
CLASS="PROGRAMLISTING"
>table &lt;spamd-white&gt; persist
table &lt;nospamd&gt; persist file "/etc/mail/nospamd"
pass in on egress proto tcp to any port smtp divert-to 127.0.0.1 port 8025
pass in on egress proto tcp from &lt;nospamd&gt; to any port smtp
pass in log on egress proto tcp from &lt;spamd-white&gt; to any port smtp
pass out log on egress proto tcp to any port smtp</PRE
><P
>or in pre-OpenBSD 4.7 syntax:</P
><PRE
CLASS="PROGRAMLISTING"
>table &lt;spamd-white&gt; persist
table &lt;nospamd&gt; persist file "/etc/mail/nospamd"
rdr pass in on egress proto tcp to any port smtp -&gt; 127.0.0.1 port 8025
pass in on egress proto tcp from &lt;nospamd&gt; to any port smtp
pass in log on egress proto tcp from &lt;spamd-white&gt; to any port smtp
pass out log on egress proto tcp to any port smtp</PRE
><P
>We have two tables, for now it's sufficient to note their names and the
fact that these names have a special meaning in this context.  SMTP
traffic will be redirected to daemon listening on port 8025 unless the source addresses are to be found in one of the tables.</P
><P
>The application which uses these tables,
<SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/spamd"
TARGET="_top"
>spamd</A
></SPAN
>, is a fake SMTP daemon, designed to
waste spammers' time and keep their traffic off our net.  That's what
lives at port 8025, and the last part of our session here will be
centered around how to make good use of that software.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./note.jpg"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>This is about the OpenBSD spam deferral daemon <A
HREF="http://man.openbsd.org/spamd"
TARGET="_top"
>spamd(8)</A
>, not the Spamassassin component</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Please note that this text describes the OpenBSD spam deferral daemon <A
HREF="http://man.openbsd.org/spamd"
TARGET="_top"
>spamd(8)</A
>, not the similarly named program that is part of the Apache project's SpamAssassin content filtering system. The spam deferral daemon and the content filtering system complement each other well and can even coexist on the same system (the binaries install to different paths unless you've done something you shouldn't have). If you're primarily interested in the content filterling system, please head over to <A
HREF="http://spamassassin.apache.org/"
TARGET="_top"
>spamassassin.apache.org</A
> for information on that system.
  </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="SPAMD.NOTALONE"
>Remember, you are not alone: blacklisting</A
></H2
><P
>The main point underlying the <SPAN
CLASS="APPLICATION"
>spamd</SPAN
> design
is the fact that spammers send a large number of messages, and the
probability that you are the first person receiving a particular
message is incredibly small.  In addition, spam is mainly sent via a
few spammer friendly networks and a large number of hijacked machines.
Both the individual messages and the machines will be reported to
blacklists fairly quickly, and this is the data which eventually
ends up in the first table in our example.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="SPAMD.TARANDGREY"
>List of black and grey, and the sticky tarpit</A
></H2
><P
>What <SPAN
CLASS="APPLICATION"
>spamd</SPAN
> does to SMTP connections from
addresses in the blacklist is to present its banner and immediately
switch to a mode where it answers SMTP traffic 1 byte at the time.
This technique, which is intended to waste as much time as possible on
the sending end while costing the receiver pretty much nothing, is
called <I
CLASS="FIRSTTERM"
>tarpitting</I
>.  The specific implementation
with 1 byte SMTP replies is often referred to as
<I
CLASS="FIRSTTERM"
>stuttering</I
>.</P
><P
><SPAN
CLASS="APPLICATION"
>spamd</SPAN
> also supports
<I
CLASS="FIRSTTERM"
>greylisting</I
>, which works by rejecting messages
from unknown hosts temporarily with 45n codes, letting messages from
hosts which try again within a reasonable time through.  Traffic from
well behaved hosts, that is, senders which are set up to behave within
the limits set up in the relevant RFCs<A
NAME="AEN1637"
HREF="#FTN.AEN1637"
><SPAN
CLASS="footnote"
>[28]</SPAN
></A
>, will be let through. </P
><P
>Greylisting as a technique was presented in a 2003 paper by Evan
Harris<A
NAME="AEN1640"
HREF="#FTN.AEN1640"
><SPAN
CLASS="footnote"
>[29]</SPAN
></A
>, and a number of implementations followed over
the next few months.  OpenBSD's <SPAN
CLASS="APPLICATION"
>spamd</SPAN
>
aquired its ability to greylist in version OpenBSD 3.5, which was
released in May 2004.  Starting with OpenBSD 4.1,
<SPAN
CLASS="APPLICATION"
>spamd</SPAN
> by default runs in greylisting mode.</P
><P
>The most amazing thing about greylisting, apart from its simplicity, is
that it still works.  Spammers and malware writers have been very slow
to adapt. We will see a few examples later.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="SPAMD.SETUP"
>Setting up <SPAN
CLASS="APPLICATION"
>spamd</SPAN
></A
></H2
><P
>With the necessary rules in place in your
<TT
CLASS="FILENAME"
>pf.conf</TT
>, configuring spamd is fairly
straightforward<A
NAME="AEN1651"
HREF="#FTN.AEN1651"
><SPAN
CLASS="footnote"
>[30]</SPAN
></A
>.  You simply edit your <TT
CLASS="FILENAME"
>spamd.conf</TT
> (traditionally stored in the <TT
CLASS="FILENAME"
>/etc</TT
> directory, but on OpenBSD 4.1 and newer the file has migrated to <TT
CLASS="FILENAME"
>/etc/mail</TT
>),
according to your own needs.  The file itself offers quite a bit of
explanation, and the man page offers additional information, but we
will recap the essentials here.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./note.jpg"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>This is about the OpenBSD spam deferral daemon <A
HREF="http://man.openbsd.org/spamd"
TARGET="_top"
>spamd(8)</A
>, not the Spamassassin component</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Please note that this text describes the OpenBSD spam deferral daemon <A
HREF="http://man.openbsd.org/spamd"
TARGET="_top"
>spamd(8)</A
>, not the similarly named program that is part of the Apache project's SpamAssassin content filtering system. The spam deferral daemon and the content filtering system complement each other well and can even coexist on the same system (the binaries install to different paths unless you've done something you shouldn't have). If you're primarily interested in the content filterling system, please head over to <A
HREF="http://spamassassin.apache.org/"
TARGET="_top"
>spamassassin.apache.org</A
> for information on that system.
  </P
></TD
></TR
></TABLE
></DIV
><P
>One of the first lines without a <KBD
CLASS="USERINPUT"
>#</KBD
> comment sign
at the start contains the block which defines the
<KBD
CLASS="USERINPUT"
>all</KBD
> list, which specifies the lists you actually
use:</P
><PRE
CLASS="PROGRAMLISTING"
>all:\
:bsdly:whitelist:</PRE
><P
>Here you add all black lists you want to use, separated by colons (:).
If you want to use whitelists to subtract addresses from your blacklist, you 
add the name of the whitelist immediately after the name of each blacklist, ie 
<KBD
CLASS="USERINPUT"
>:blacklist:whitelist:</KBD
>.  </P
><P
>Next up is a blacklist definition:</P
><PRE
CLASS="PROGRAMLISTING"
>bsdly:\
        :black:\
        :msg="SPAM.  Your address %A has sent spam within the last 24 hours.  See http://www.bsdly.net/~peter/traplist.shtml for details.":\
        :method=http:\
        :file=www.bsdly.net/~peter/bsdly.net.traplist</PRE
><P
>Following the name, the first data field specifies the list type, in
this case <KBD
CLASS="USERINPUT"
>black</KBD
>.  The
<I
CLASS="FIRSTTERM"
>msg</I
> field contains the message to display to
blacklisted senders during the SMTP dialogue.  The
<I
CLASS="FIRSTTERM"
>method</I
> field specifies how spamd-setup fetches
the list data, here <KBD
CLASS="USERINPUT"
>http</KBD
>.  The other options
are fetching via <KBD
CLASS="USERINPUT"
>ftp</KBD
>, from a
<KBD
CLASS="USERINPUT"
>file</KBD
> in a mounted file system or via
<KBD
CLASS="USERINPUT"
>exec</KBD
> of an external program.  Finally the
<I
CLASS="FIRSTTERM"
>file</I
> field specifies the name of the file spamd
expects to receive.</P
><P
>The definition of a whitelist follows much the same pattern:</P
><PRE
CLASS="PROGRAMLISTING"
>whitelist:\
        :white:\
        :method=file:\
        :file=/etc/mail/whitelist.txt</PRE
><P
>but omits the message parameter since a message is not needed.</P
><DIV
CLASS="TIP"
><P
></P
><TABLE
CLASS="TIP"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./tip.jpg"
HSPACE="5"
ALT="Tip"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>Choose your data sources with care</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Enabling the suggested blacklists in earlier versions of the default as distributed
<TT
CLASS="FILENAME"
>spamd.conf</TT
> could lead to blacklisting of quite
large blocks of the Internet, including several countries such as
Korea.  I work in a company which actually does the odd bit of
business with Koreans, and consequently I needed to edit out that
particular entry from our configuration.  You are the judge of which
data sources to use, and using other lists than the default ones is
possible.</P
></TD
></TR
></TABLE
></DIV
><P
>Put the lines for spamd and the startup parameters you want in your
<TT
CLASS="FILENAME"
>/etc/rc.conf</TT
> or <TT
CLASS="FILENAME"
>/etc/rc.conf.local</TT
>, for example</P
><PRE
CLASS="PROGRAMLISTING"
>spamd_flags="-v -G 2:4:864" # for normal use: "" and see spamd-setup(8)
spamd_grey=YES              # use spamd greylisting if YES</PRE
><P
>Once again, on OpenBSD 4.1 onwards, the
<KBD
CLASS="USERINPUT"
>spamd_grey</KBD
> variable is superfluous.  If you
want <SPAN
CLASS="APPLICATION"
>spamd</SPAN
> to run in pure blacklist mode
without greylisting, you use the <KBD
CLASS="USERINPUT"
>spamd_black</KBD
>
variable to turn off greylisting and enable blacklisting mode.</P
><P
>Note for that you can fine tune several of the greylisting related
parameters via <SPAN
CLASS="APPLICATION"
>spamd</SPAN
> command line
parameters.  Check the <SPAN
CLASS="APPLICATION"
>spamd</SPAN
> man page to
see what the parameters mean.</P
><P
>When you are done with editing the setup, you start
<SPAN
CLASS="APPLICATION"
>spamd</SPAN
> with the options you want, and
complete the configuration using
<SPAN
CLASS="APPLICATION"
>spamd-setup</SPAN
>.  Finally, you create a
<SPAN
CLASS="APPLICATION"
>cron</SPAN
> job which calls
<SPAN
CLASS="APPLICATION"
>spamd-setup</SPAN
> to update the tables at
reasonable intervals.</P
><P
>Once the tables are filled, you can view table contents using
<SPAN
CLASS="APPLICATION"
>pfctl</SPAN
> or other applications.  If you want
to change or delete entries, you are advised to use the
<SPAN
CLASS="APPLICATION"
>spamdb</SPAN
> utility instead of
<SPAN
CLASS="APPLICATION"
>pfctl</SPAN
> table commands.  More about that
later.</P
><P
>Note that the example above uses rdr rules which are also pass rules.
If your rdr rules do not include a 'pass' part, you need to set up
pass rules to let traffic through to your redirection.  You also need
to set up rules to let legitimate email through.  If you are already
running an email service on your network, you can probably go on using
your old SMTP pass rules.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="SPAMD.EXPERIENCE"
>Some early highlights of our <SPAN
CLASS="APPLICATION"
>spamd</SPAN
> experience</A
></H2
><P
>What is <SPAN
CLASS="APPLICATION"
>spamd</SPAN
> like in practical use? We
started using <SPAN
CLASS="APPLICATION"
>spamd</SPAN
> in earnest in early
December of 2004, after running
<SPAN
CLASS="APPLICATION"
>spamassassin</SPAN
> and
<SPAN
CLASS="APPLICATION"
>clamav</SPAN
> as parts of the
<SPAN
CLASS="APPLICATION"
>exim</SPAN
> delivery process for a while. Our
<SPAN
CLASS="APPLICATION"
>exim</SPAN
> is configured to tag and deliver
messages with a spamassassin score in the interval from 5 to 9.99
points, while discarding messages with 10 points or more along with
malware carrying messages.  As the autumn progressed,
<SPAN
CLASS="APPLICATION"
>spamassassin</SPAN
>'s success rate had been
steadily declining, letting ever more spam through.</P
><P
>When we put <SPAN
CLASS="APPLICATION"
>spamd</SPAN
> into production, the
total number of messages handled and the number of messages handled by
<SPAN
CLASS="APPLICATION"
>spamassassin</SPAN
> decreased drastically. The
number of spam messages which make it through untagged is now
stabilized at roughly five a day, based on a reporting population of a
handful of users.</P
><P
>If you start <SPAN
CLASS="APPLICATION"
>spamd</SPAN
> with the -v command line
option for verbose logging, the logs start including a few more items
of information in addition to the IP addresses.  With verbose logging,
a typical log excerpt looks like this:</P
><PRE
CLASS="PROGRAMLISTING"
>Oct  2 19:55:05 delilah spamd[26905]: (GREY) 83.23.213.115: 
&lt;gilbert@keyholes.net&gt; -&gt; &lt;wkitp98zpu.fsf@datadok.no&gt;
Oct  2 19:55:05 delilah spamd[26905]: 83.23.213.115: disconnected after 
0 seconds.
Oct  2 19:55:05 delilah spamd[26905]: 83.23.213.115: connected (2/1)
Oct  2 19:55:06 delilah spamd[26905]: (GREY) 83.23.213.115: 
&lt;gilbert@keyholes.net&gt; -&gt; &lt;wkitp98zpu.fsf@datadok.no&gt;
Oct  2 19:55:06 delilah spamd[26905]: 83.23.213.115: disconnected after 
1 seconds.
Oct  2 19:57:07 delilah spamd[26905]: (BLACK) 65.210.185.131:
 &lt;bounce-3C7E40A4B3@branch15.summer-bargainz.com&gt; -&gt; &lt;adm@dataped.no&gt;
Oct  2 19:58:50 delilah spamd[26905]: 65.210.185.131: From: Auto 
lnsurance Savings &lt;noreply@branch15.summer-bargainz.com&gt;
Oct  2 19:58:50 delilah spamd[26905]: 65.210.185.131: Subject: Start 
SAVlNG M0NEY on Auto lnsurance
Oct  2 19:58:50 delilah spamd[26905]: 65.210.185.131: To: adm@dataped.no
Oct  2 20:00:05 delilah spamd[26905]: 65.210.185.131: disconnected after 
404 seconds. lists: spews1
Oct  2 20:03:48 delilah spamd[26905]: 222.240.6.118: connected (1/0)
Oct  2 20:03:48 delilah spamd[26905]: 222.240.6.118: disconnected after 
0 seconds.
Oct  2 20:06:51 delilah spamd[26905]: 24.71.110.10: connected (1/1), 
lists: spews1
Oct  2 20:07:00 delilah spamd[26905]: 221.196.37.249: connected (2/1)
Oct  2 20:07:00 delilah spamd[26905]: 221.196.37.249: disconnected after 
0 seconds.
Oct  2 20:07:12 delilah spamd[26905]: 24.71.110.10: disconnected after 
21 seconds. lists: spews1</PRE
><P
>The first three lines say that a machine connects, as the second
active connection, with one connection from a blacklisted host. The
<SAMP
CLASS="COMPUTEROUTPUT"
>(GREY)</SAMP
> and
<SAMP
CLASS="COMPUTEROUTPUT"
>(BLACK)</SAMP
> before the addresses indicate
greylisting or blacklisting status, respectively.  After 404 seconds
(or 6 minutes, 44 seconds), the blacklisted host gives up without
completing the delivery.  The following lines may be the first ever
contact from a machine, which is then greylisted.<A
NAME="AEN1739"
HREF="#FTN.AEN1739"
><SPAN
CLASS="footnote"
>[31]</SPAN
></A
></P
><P
>At the time this tutorial was originally written, our preliminary
conclusion was that <SPAN
CLASS="APPLICATION"
>spamd</SPAN
> was quite
efficient in stopping spam.  Unfortunately, along the way we
encountered some false positives.  Indications are that the false
positives came from a few too broadly defined entries in the spews2
(spews level 2) list.  For now we have stopped using this list as a
blacklist, without a noticeable increase in the spam volume.</P
><P
>Now for what used to be the the climax of my spamd experience. One log
entry stood out for a long time:</P
><PRE
CLASS="SCREEN"
>Dec 11 23:57:24 delilah spamd[32048]: 69.6.40.26: connected (1/1), 
lists: spamhaus spews1 spews2
Dec 12 00:30:08 delilah spamd[32048]: 69.6.40.26: disconnected 
after 1964 seconds. lists: spamhaus spews1 spews2</PRE
><P
>This entry concerns a sender at wholesalebandwidth.com. This particular
machine made 13 attempts at delivery during the period from December 9th 
to December 12th, 2004. The last attempt lasted 32 minutes, 44 seconds, 
without completing the delivery.</P
><P
>I update the tutorial now and again, and recently I found a few more entries which exceeded this:</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>grep disconnected /var/log/spamd | awk '{print $9}' \
| sort -rn | uniq -c | head</KBD
>
<SAMP
CLASS="COMPUTEROUTPUT"
>   1 42673
   1 36099
   1 14714
   1 10170
   1 5495
   1 3025
   1 2193
   1 1964
   1 1872
   1 1718</SAMP
></PRE
><P
>The first, at 42673 seconds, which is almost twelve hours, </P
><PRE
CLASS="SCREEN"
>Dec 21 14:22:44 delilah spamd[29949]: 85.152.224.147: connected (5/2)
Dec 21 14:22:46 delilah spamd[29949]: 85.152.224.147: connected (6/2)
Dec 21 14:22:47 delilah spamd[29949]: 85.152.224.147: disconnected
after 3 seconds.
Dec 22 02:13:59 delilah spamd[29949]: 85.152.224.147: disconnected
after 42673 seconds.</PRE
><P
>concerns a host which is apparently in a Spanish telecoms operator's
network.  The machine was probably infected by an extremely naive spam
sending worm, which just took a long time waiting for the rest of the
SMTP dialogue.  The next entries, at 10 hours, 1 minute, 39 seconds, 4
hours, 5 minutes and 14 seconds and 2 hours, 49 minutes and 30 seconds
respectively, seem to have behaved in much the same way.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="SPAMD.GREYTRAPPING"
>Beating'em up some more: <SPAN
CLASS="APPLICATION"
>spamdb</SPAN
> and greytrapping</A
></H2
><P
>Behind the scenes, rarely mentioned and barely documented are two of
<SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/spamd"
TARGET="_top"
>spamd</A
></SPAN
>'s helpers, the
<SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/spamdb"
TARGET="_top"
>spamdb</A
></SPAN
> database tool and the
<SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/spamlogd"
TARGET="_top"
>spamlogd</A
></SPAN
> whitelist updater, which both
perform essential functions for the greylisting feature.  Of the two
<SPAN
CLASS="APPLICATION"
>spamlogd</SPAN
> works quietly in the background,
while <SPAN
CLASS="APPLICATION"
>spamdb</SPAN
> has been developed to offer
some interesting features.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./note.jpg"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>Restart <SPAN
CLASS="APPLICATION"
>spamd</SPAN
> to enable greylisting</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If you followed all steps in the tutorial exactly up to this point,
<SPAN
CLASS="APPLICATION"
>spamlogd</SPAN
> has been started automatically
already.  However, if your initial <SPAN
CLASS="APPLICATION"
>spamd</SPAN
>
configuration did not include greylisting,
<SPAN
CLASS="APPLICATION"
>spamlogd</SPAN
> may not have been started, and you
may experience strange symptoms, such as your greylists and whitelist
not getting updated properly.</P
><P
>Under normal circumstances, you should not have to start
<SPAN
CLASS="APPLICATION"
>spamlogd</SPAN
> by hand.  Restarting
<SPAN
CLASS="APPLICATION"
>spamd</SPAN
> after you have enabled greylisting
ensures <SPAN
CLASS="APPLICATION"
>spamlogd</SPAN
> is loaded and available
too.</P
></TD
></TR
></TABLE
></DIV
><P
><SPAN
CLASS="APPLICATION"
>spamdb</SPAN
> is the administrator's main interface
to managing the black, grey and white lists via the contents of the
<TT
CLASS="FILENAME"
>/var/db/spamdb</TT
> database.</P
><P
>Early versions of <SPAN
CLASS="APPLICATION"
>spamdb</SPAN
> simply offered
options to add whitelist entries to the database or update existing
ones (<KBD
CLASS="USERINPUT"
>spamdb -a nn.mm.nn.mm </KBD
>) and to delete
whitelist entries (<KBD
CLASS="USERINPUT"
>spamdb -d nn.mm.nn.mm</KBD
>) to
compensate for shortcomings in either the blacklists used or the
effects of the greylisting algorithms.</P
><P
>By the time the development cycle for OpenBSD 3.8 started during the
first half of 2005, <SPAN
CLASS="APPLICATION"
>spamd</SPAN
> users and
developers had accumulated significant amounts of data and experience
on spammer behaviour and spammer reactions to countermeasures.</P
><P
>We already know that spam senders rarely use a fully compliant SMTP
implementation to send their messages.  That's why greylisting works.
Also, as we noted earlier, not only do spammers send large numbers of
messages, they rarely check that the addresses they feed to their
hijacked machines are actually deliverable.  Combine these facts, and
you see that if a greylisted machine tries to send a message to an
invalid address in your domain, there is a significant probability
that the message is a spam, or for that matter, malware.</P
><P
></P
><DIV
CLASS="SECTION"
><HR><H3
CLASS="SECTION"
><A
NAME="SPAMD.GREYTRAPPING.WHY"
>Enter greytrapping</A
></H3
><P
>Consequently, <SPAN
CLASS="APPLICATION"
>spamd</SPAN
> had to learn
<I
CLASS="FIRSTTERM"
>greytrapping</I
>.  Greytrapping as implemented in
<SPAN
CLASS="APPLICATION"
>spamd</SPAN
> puts offenders in a temporary
blacklist, dubbed <TT
CLASS="FILENAME"
>spamd-greytrap</TT
>, for 24 hours.
Twenty-four hours is short enough to not cause serious disruption of
legitimate traffic, since real SMTP implementations will keep trying to
deliver for a few days at least.  Experience from large scale
implementations of the technique shows that it rarely if ever produces
false positives<A
NAME="AEN1795"
HREF="#FTN.AEN1795"
><SPAN
CLASS="footnote"
>[32]</SPAN
></A
>
.  Machines which continue spamming after 24 hours will
make it back to the tarpit soon enough.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H3
CLASS="SECTION"
><A
NAME="SPAMD.GREYTRAPPING.HOW"
>Your own traplist</A
></H3
><P
>To set up your own traplist, you use
<SPAN
CLASS="APPLICATION"
>spamdb</SPAN
>'s <KBD
CLASS="USERINPUT"
>-T</KBD
> option.
In my case, the strange address I mentioned earlier<A
NAME="AEN1804"
HREF="#FTN.AEN1804"
><SPAN
CLASS="footnote"
>[33]</SPAN
></A
> was a natural candidate for inclusion:</P
><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>$</SAMP
><KBD
CLASS="USERINPUT"
> spamdb -T -a wkitp98zpu.fsf@datadok.no</KBD
></PRE
><P
>Sure enough, the spammers thought this was just as usable as almost two years ago:</P
><PRE
CLASS="PROGRAMLISTING"
>Nov  6 09:50:25 delilah spamd[23576]: 210.214.12.57: connected (1/0)
Nov  6 09:50:32 delilah spamd[23576]: 210.214.12.57: connected (2/0)
Nov  6 09:50:40 delilah spamd[23576]: (GREY) 210.214.12.57: 
&lt;gilbert@keyholes.net&gt; -&gt; &lt;wkitp98zpu.fsf@datadok.no&gt;
Nov  6 09:50:40 delilah spamd[23576]: 210.214.12.57: disconnected 
after 15 seconds.
Nov  6 09:50:42 delilah spamd[23576]: 210.214.12.57: connected (2/0)
Nov  6 09:50:45 delilah spamd[23576]: (GREY) 210.214.12.57: 
&lt;bounce-3C7E40A4B3@branch15.summer-bargainz.com&gt; -&gt; 
&lt;adm@dataped.no&gt;
Nov  6 09:50:45 delilah spamd[23576]: 210.214.12.57: disconnected 
after 13 seconds.
Nov  6 09:50:50 delilah spamd[23576]: 210.214.12.57: connected (2/0)
Nov  6 09:51:00 delilah spamd[23576]: (GREY) 210.214.12.57: 
&lt;gilbert@keyholes.net&gt; -&gt; &lt;wkitp98zpu.fsf@datadok.no&gt;
Nov  6 09:51:00 delilah spamd[23576]: 210.214.12.57: disconnected 
after 18 seconds.
Nov  6 09:51:02 delilah spamd[23576]: 210.214.12.57: connected (2/0)
Nov  6 09:51:02 delilah spamd[23576]: 210.214.12.57: disconnected 
after 12 seconds.
Nov  6 09:51:02 delilah spamd[23576]: 210.214.12.57: connected (2/0)
Nov  6 09:51:18 delilah spamd[23576]: (GREY) 210.214.12.57: 
&lt;gilbert@keyholes.net&gt; -&gt; &lt;wkitp98zpu.fsf@datadok.no&gt;
Nov  6 09:51:18 delilah spamd[23576]: 210.214.12.57: disconnected 
after 16 seconds.
Nov  6 09:51:18 delilah spamd[23576]: (GREY) 210.214.12.57: 
&lt;bounce-3C7E40A4B3@branch15.summer-bargainz.com&gt; -&gt; 
&lt;adm@dataped.no&gt;
Nov  6 09:51:18 delilah spamd[23576]: 210.214.12.57: disconnected 
after 16 seconds.
Nov  6 09:51:20 delilah spamd[23576]: 210.214.12.57: connected (1/1), 
lists: spamd-greytrap
Nov  6 09:51:23 delilah spamd[23576]: 210.214.12.57: connected (2/2), 
lists: spamd-greytrap
Nov  6 09:55:33 delilah spamd[23576]: (BLACK) 210.214.12.57: 
&lt;gilbert@keyholes.net&gt; -&gt; &lt;wkitp98zpu.fsf@datadok.no&gt;
Nov  6 09:55:34 delilah spamd[23576]: (BLACK) 210.214.12.57: 
&lt;bounce-3C7E40A4B3@branch15.summer-bargainz.com&gt; -&gt; 
&lt;adm@dataped.no&gt;</PRE
><P
>This log fragment shows how the spammer's machine is greylisted at
first contact, and then clumsily tries to deliver messages to my
greytrap address, only to end up in the
<TT
CLASS="FILENAME"
>spamd-greytrap</TT
> blacklist after a few minutes.  By
now we all know what it will be doing for the next twenty-odd hours.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H3
CLASS="SECTION"
><A
NAME="SPAMD.GREYTRAPPING.MISC"
>Deleting, handling trapped entries</A
></H3
><P
><SPAN
CLASS="APPLICATION"
>spamdb</SPAN
> offers a few more options you should
be aware of.  The <KBD
CLASS="USERINPUT"
>-T</KBD
> option combined with
<KBD
CLASS="USERINPUT"
>-d</KBD
> lets you delete traplist mail address
entries, while the <KBD
CLASS="USERINPUT"
>-t</KBD
> (lowercase) option
combined with <KBD
CLASS="USERINPUT"
>-a</KBD
> or <KBD
CLASS="USERINPUT"
>-d</KBD
>
lets you add or delete trapped IP address entries from the database.</P
><P
>Exporting your list of currently trapped addresses can be as simple as
putting together a simple one-liner with
<SPAN
CLASS="APPLICATION"
>spamdb</SPAN
>, <SPAN
CLASS="APPLICATION"
>grep</SPAN
> and
a little imagination.</P
></DIV
><DIV
CLASS="SECTION"
><HR><H3
CLASS="SECTION"
><A
NAME="DOWNSIDE-WHITELISTING"
>The downside: some people really do not get it</A
></H3
><P
>We have already learned that the main reason why greylisting works is
that any standards compliant mail setup is required to retry delivery
after some &ldquo;reasonable&rdquo; amount of time.  However as Murphy
will be all too happy to tell you, life is not always that simple.  </P
><P
>For one thing, the first email message sent from any site which has
not contacted you for as long as the greylister keeps its data around
will be delayed for some random amount of time which depends mainly on
the sender's retry interval.  There are some circumstances where
avoiding even a minimal delay is desirable.  If you for example have
some infrequent customers who always demand your immediate and urgent
attention to their business when they do contact you, an initial
delivery delay of what could be several hours may not be optimal.</P
><P
>In addition, you are bound to encounter misconfigured mail servers
which either do not retry at all or retry too quickly, perhaps
stopping delivery retries after a few attempts.  As luck would have
it, in your case one of these is likely to be at an important
customer's site, run by an incompetent who will not listen to reason
or possibly a site owned and operated by your boss' boyfriend.</P
><P
>Finally, there are some sites which are large enough to have several
outgoing SMTP servers, and not play well with greylisting since they
are not guaranteed to retry delivery of any given message from the
same IP address as the last delivery attempt for that message.  Even
though those sites can sincerely claim to comply with the retry
requirements, since the RFCs do no state that the new delivery
attempts <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>have to</I
></SPAN
> come from the same IP address,
it's fairly obvious that this is one of the few remaining downsides of
greylisting.</P
><P
>If you need to compensate for such things in your setup, it is fairly
easy to do.  One useful approach is to define a table for a local
whitelist, to be fed from a file in case of reboots:</P
><PRE
CLASS="PROGRAMLISTING"
>table &lt;localwhite&gt; file "/etc/mail/whitelist.txt"</PRE
><P
>To make sure SMTP traffic from the addresses in the table is not fed
to spamd, you add a <KBD
CLASS="USERINPUT"
>no rdr</KBD
> rule at the top of
your redirection block:</P
><PRE
CLASS="PROGRAMLISTING"
>no rdr proto tcp from &lt;localwhite&gt; to $mailservers port smtp</PRE
><P
>Once you have these changes added to your rule set, you enter the
addresses you need to protect from redirection into the
<TT
CLASS="FILENAME"
>whitelist.txt</TT
> file, then reload your rule set
using <KBD
CLASS="USERINPUT"
>pfctl -f</KBD
>.  You can then use all the
expected table tricks on the <KBD
CLASS="USERINPUT"
>&lt;localwhite&gt;</KBD
>
table, including replacing its content after editing the
<TT
CLASS="FILENAME"
>whitelist.txt</TT
> file.  See <A
HREF="#TABLES"
>the Chapter called <I
>Tables make your life easier</I
></A
>
or <KBD
CLASS="USERINPUT"
>man pfctl</KBD
> for a few pointers.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./note.jpg"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>Even better: copy rules from the man page and use <TT
CLASS="FILENAME"
>nospamd</TT
></B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>    Recent-ish versions of the <A
HREF="http://man.openbsd.org/spamd"
TARGET="_top"
>spamd(8)</A
> man page have <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>exactly</I
></SPAN
> the rules you need, including the <KBD
CLASS="USERINPUT"
>nospamd</KBD
> table:
  </P
><PRE
CLASS="SCREEN"
>table &lt;spamd-white&gt; persist
table &lt;nospamd&gt; persist file "/etc/mail/nospamd"
pass in on egress proto tcp to any port smtp divert-to 127.0.0.1 port spamd
pass in on egress proto tcp from &lt;nospamd&gt; to any port smtp
pass in log on egress proto tcp from &lt;spamd-white&gt; to any port smtp
pass out log on egress proto tcp to any port smtp
  </PRE
><P
>Please stick to exactly those rules unless you have a very good reason to introduce local variations. If you need some initial content for your <KBD
CLASS="USERINPUT"
>nospamd</KBD
> file, you can fetch mine (which is based on sediments of extracted <A
HREF="https://en.wikipedia.org/wiki/Sender_Policy_Framework"
TARGET="_top"
>SPF</A
>records from various domains over the years) from <A
HREF="https://home.nuug.no/~peter/nospamd"
TARGET="_top"
>here</A
> or use Aaron Poffenbergers excellent <A
HREF="https://github.com/akpoff/spf_fetch"
TARGET="_top"
>spf_fetch</A
> which intends to automate fetching of SPF records for a list of domains.
  </P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="SPAMD.CONCLUSION"
>Conclusions from our <SPAN
CLASS="APPLICATION"
>spamd</SPAN
> experience</A
></H2
><P
>Summing up, selectively used, blacklists combined with spamd are powerful,
precise and efficient spam fighting tools. The load on the spamd machine
is minimal. On the other hand, spamd will never perform better than its
weakest data source, which means you will need to monitor your logs
and use whitelisting when necessary.</P
><P
>It is also perfectly feasible to run <SPAN
CLASS="APPLICATION"
>spamd</SPAN
>
in a pure greylisting mode, with no blacklists.  In fact some users
report that a purely greylisting <SPAN
CLASS="APPLICATION"
>spamd</SPAN
>
configuration is not significantly less effective than blacklising
configurations as spam fighting tools<A
NAME="AEN1864"
HREF="#FTN.AEN1864"
><SPAN
CLASS="footnote"
>[34]</SPAN
></A
>.</P
><P
>For our main blacklist, we ended up using Bob Beck's
traplist
until it was retired from use in May 2016. </P
><P
>You can find my field notes from a recent greytrapping experiment in my blog at <A
HREF="http://bsdly.blogspot.com"
TARGET="_top"
>bsdly.blogspot.com</A
>, starting with <A
HREF="http://bsdly.blogspot.com/2007/07/hey-spammer-heres-list-for-you.html"
TARGET="_top"
>the entry dated July 9, 2007</A
>. The articles <A
HREF="http://bsdly.blogspot.com/2012/05/in-name-of-sane-email-setting-up-spamd.html"
TARGET="_top"
>In The Name Of Sane Email: Setting Up OpenBSD's spamd(8) With Secondary MXes In Play - A Full Recipe</A
> and <A
HREF="http://bsdly.blogspot.com/2013/04/maintaining-publicly-available.html"
TARGET="_top"
>Maintaining A Publicly Available Blacklist - Mechanisms And Principles</A
> describe a more stable state of the system. And of course the main recommendation here is to read
  <A
HREF="http://www.nostarch.com/pf3"
TARGET="_top"
>The Book of PF</A
>, which contains a somewhat more thorough treatment of spamd and related techniques.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="PFHAIKU"
></A
>PF - Haiku</H1
><P
>Finally, an indication of the level of feeling inspired by PF in its
users is in order. On the PF mailing list, a message with the subject
of "Things pf can't do?" appeared in May 2004. The message had been
written by someone who did not have a lot of firewalls experience, and
who consequently found it hard to get the setup he or she wanted.</P
><P
>&#13;This, of course, lead to some discussion, with several participants
saying that if PF was hard on a newbie, the alternatives were
certainly not a bit better. The thread ended in the following haiku of
praise from Jason Dixon, which is given intact as it came, along with
Jason's comments:</P
><PRE
CLASS="SCREEN"
>Compared to working with iptables, PF is like this haiku:

A breath of fresh air,
floating on white rose petals,
eating strawberries.

Now I'm getting carried away:

Hartmeier codes now,
Henning knows not why it fails,
fails only for n00b.

Tables load my lists,
tarpit for the asshole spammer,
death to his mail store.

CARP due to Cisco,
redundant blessed packets,
licensed free for me.</PRE
><P
>Jason Dixon, on the PF email list, May 20th, 2004 (<A
HREF="http://marc.info/?l=openbsd-pf&#38;m=108507584013046&#38;w=2"
TARGET="_top"
>http://marc.info/?l=openbsd-pf&amp;m=108507584013046&amp;w=2</A
>)</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="REFERENCES"
></A
>References</H1
><P
>OpenBSDs web <A
HREF="http://www.openbsd.org/"
TARGET="_top"
>http://www.openbsd.org/</A
></P
><P
>OpenBSDs FAQ, <A
HREF="http://www.openbsd.org/faq/index.html"
TARGET="_top"
>http://www.openbsd.org/faq/index.html</A
></P
><P
>PF User Guide <A
HREF="http://www.openbsd.org/faq/pf/index.html"
TARGET="_top"
>http://www.openbsd.org/faq/pf/index.html</A
></P
><P
>Daniel Hartmeier's PF pages, <A
HREF="http://www.benzedrine.ch/pf.html"
TARGET="_top"
>http://www.benzedrine.ch/pf.html</A
></P
><P
>Daniel Hartmeier: Design and Performance of the OpenBSD Stateful Packet Filter (pf), 
<A
HREF="http://www.benzedrine.ch/pf-paper.html"
TARGET="_top"
>http://www.benzedrine.ch/pf-paper.html</A
> (presented at Usenix 2002)</P
><P
>Unix.se: Brandvgg med OpenBSD, <A
HREF="http://unix.se/Brandv%E4gg_med_OpenBSD"
TARGET="_top"
>http://unix.se/Brandv%E4gg_med_OpenBSD</A
></P
><P
>RFC 1631, "The IP Network Address Translator (NAT)", May 1994 <A
HREF="http://www.ietf.org/rfc/rfc1631.txt?number=1631"
TARGET="_top"
>http://www.ietf.org/rfc/rfc1631.txt?number=1631</A
></P
><P
>RFC 1918, "Address Allocation for Private Internets", February 1996 <A
HREF="http://www.ietf.org/rfc/rfc1918.txt?number=1918"
TARGET="_top"
>http://www.ietf.org/rfc/rfc1918.txt?number=1918</A
></P
><P
>The FreeBSD PF home page, <A
HREF="http://pf4freebsd.love2party.net/"
TARGET="_top"
>http://pf4freebsd.love2party.net/</A
> </P
><P
>Marcus Ranum: <A
HREF="http://www.ranum.com/security/computer_security/editorials/dumb/index.html"
TARGET="_top"
>The
Six Dumbest Ideas in Computer Security</A
>, September 1, 2005</P
><P
>Greylisting.org <A
HREF="http://www.greylisting.org/"
TARGET="_top"
>greylisting.org</A
> is the home
of all things greylisting, with links to numerous articles and other useful information.</P
><P
>Evan Harris: <A
HREF="http://greylisting.org/articles/whitepaper.shtml"
TARGET="_top"
>The Next Step in the Spam Control War: Greylisting</A
> (the original greylisting paper)</P
><P
>Mark Uemura: <A
HREF="http://undeadly.org/cgi?action=article&#38;sid=20080324141004"
TARGET="_top"
> What's New in 4.3: authpf-noip</A
></P
><P
>Henning Brauer: <A
HREF="http://bulabula.org/carp-and-stp-meet-switch-security.html"
TARGET="_top"
>Carp and STP meet switch security</A
></P
><P
>Michael W. Lucas: <A
HREF="http://nostarch.com/networkflow.htm"
TARGET="_top"
>Network Flow Analysis</A
>, No Starch Press 2010</P
><P
>Peter N. M. Hansteen: <A
HREF="http://bsdly.blogspot.com/2014/02/effective-spam-and-malware.html"
TARGET="_top"
>Effective Spam and Malware Countermeasures - Network Noise Reduction Using Free Tools </A
> - originally a paper presented at BSDCan 2007 which puts
<SPAN
CLASS="APPLICATION"
>spamd</SPAN
> into a slightly wider spam and
malware fighting context along with some data on spammer behavior, this 2013 update contains some updates relevant to present conditions.</P
><P
>Peter N. M. Hansteen: <A
HREF="http://www.nostarch.com/pf3"
TARGET="_top"
>The Book of
PF</A
>, No Starch Press 2014 (<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>second edition</I
></SPAN
> in November 2010, first published 2007), is an expanded and extensively rewritten
followup to the tutorial, and covers a range of advanced topics in
addition to those covered here.</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="WEBHOME"
></A
>Where to find the tutorial on the web</H1
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Work in progress edition:</I
></SPAN
> </P
><P
>Several formats <A
HREF="http://home.nuug.no/~peter/pf/"
TARGET="_top"
>http://home.nuug.no/~peter/pf/</A
></P
><P
>This is where updated versions will appear more or less in the
natural course of tinkering, in between events.  Please let me know if
you want to be told of future updates. That page usually also contains links to the latest version of the slides belonging to the somewhat more extensive PF tutorial.</P
><DIV
CLASS="SECTION"
><HR><H2
CLASS="SECTION"
><A
NAME="SUPPPORTTHEPROJECT"
>If you enjoyed this: Buy OpenBSD CDs and other items, donate!</A
></H2
><P
>If you have enjoyed this tutorial or found it useful, please go to the
<A
HREF="http://www.openbsd.org/orders.html"
TARGET="_top"
>OpenBSD.org Orders
page</A
> and buy CD sets, or for that matter, support further
development work by the OpenBSD project via a <A
HREF="http://www.openbsd.org/donations.html"
TARGET="_top"
>donation</A
>.</P
><P
>If you are in a position to donate hardware, make sure you check
OpenBSD developers' hardware wishlist at <A
HREF="http://www.openbsd.org/want.html"
TARGET="_top"
>http://www.openbsd.org/want.html</A
>
and get in contact with the right people in the project to arrange the
details.</P
><P
>If you've taken this in at a conference, there might even be an
OpenBSD booth nearby where you can buy CDs, T-shirts or other items.</P
><P
>Remember, even free software takes real work and real money to develop
and maintain.</P
><DIV
CLASS="NOTE"
><A
NAME="BOOKOFPF"
></A
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./note.jpg"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>The Book of PF</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><A
HREF="http://www.nostarch.com/pf3"
TARGET="_top"
>The Book of
PF</A
>, by the same author, was initially published by No Starch Press at
the end of 2007, and was succeeded by the <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>second edition</I
></SPAN
> in November 2010, and again updated for a <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>third edition</I
></SPAN
> in 2014.  The book is an expanded and extensively rewritten
followup to the tutorial, and covers a range of advanced topics in
addition to those covered here.  You can buy it through the first link
and let me have a slightly larger amount for that copy and sooner, or
you could go to <A
HREF="http://www.openbsd.org/books.html#book8"
TARGET="_top"
>The OpenBSD
Bookstore</A
>.</P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN302"
HREF="#AEN302"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>This document is now in minimal maintenance mode after 10 years as a 'work in progress', and is a slightly further developed version of 
a manuscript prepared for a lecture which was announced as (translated from Norwegian):
  "This lecture is about firewalls and related functions, with examples from
   real life with the OpenBSD project's PF (Packet Filter). PF offers
   firewalling, NAT, traffic control and bandwidth management in a single,
   flexible and sysadmin friendly system. Peter hopes that the lecture
   will give you some ideas about how to control your network traffic 
   the way you want - keeping some things outside your network, directing
   traffic to specified hosts or services, and of course, giving spammers
   a hard time." </P
><P
>   People who have offered significant and useful input regarding this
   manuscript include Eystein Roll Aarseth, David Snyder, Peter
   Postma, Henrik Kramshj, Vegard Engen, Greg Lehey, Ian Darwin,
   Daniel Hartmeier, Mark Uemura, Hallvor Engen and probably a few
   who will remain lost in my mail archive until I can
   <SPAN
CLASS="APPLICATION"
>grep</SPAN
> them out of there.
   </P
><P
>   I would like to thank the following organizations for their kind
   support: The NUUG Foundation for a travel grant which partly
   financed my AUUG2005 appearance; The AUUG, BLUG, BSD-DK, NUUG, UKUUG, SANE, BSDCan,
   EuroBSDCon and AsiaBSDCon organizations for inviting me to their
   conferences or other events; the FreeBSD Foundation for sponsoring my
   trips to BSDCan 2006 and EuroBSDCon 2006 and finally my 
   former collegues at FreeCode AS for letting me allocate some time for
   conferences and writing during 2009 and early 2010.
   </P
><P
>   The main point in making this version available is to offer an update 
   with OpenBSD 4.7 syntax, a secondary consideration is to introduce the 
   reader to the somewhat more comprehensive treatment of all topics by
   referring to <A
HREF="http://www.nostarch.com/pf3"
TARGET="_top"
>The Book of PF</A
> 
   (now in its third edition) when relevant. The last pre-OpenBSD 4.7 version of this document has 
   been preserved at <A
HREF="../en.old/"
TARGET="_top"
>this location</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN352"
HREF="#AEN352"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>It is worth noting that the IPFilter copyright episode spurred the
OpenBSD team to perform a <I
CLASS="FIRSTTERM"
>license audit</I
> of the
entire source tree and ports in order to avoid similar situations in
the future.  A number of potential problems were uncovered and
resolved over the months that followed, removing a number of potential
license pitfalls for everyone involved in free software development.
Theo de Raadt summed up the effort in a message to the openbsd-misc
mailing list on February 20th, 2003, available among others from
<A
HREF="http://marc.info/?l=openbsd-misc&#38;m=104570938124454&#38;w=2"
TARGET="_top"
>the
MARC mailing list archives</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN384"
HREF="#AEN384"
><SPAN
CLASS="footnote"
>[3]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>But even with the point at which the unassigned ranges of IPv4 addresses is about to run out only months away, IPv6 adoption is still in the early stages.  And as luck would have it as more people are starting to look at the newer generation protocols in earnest, issues are discovered, some with potentially serious security implications such as the ICMP6 design flaw which generated some controversy in early 2007.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN392"
HREF="#AEN392"
><SPAN
CLASS="footnote"
>[4]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>The two documents are RFC 1631, "The IP Network Address Translator (NAT)", dated May 1994 and
RFC 1918, "Address Allocation for Private Internets", dated February 1996. 
See <A
HREF="#REFERENCES"
>the Chapter called <I
>References</I
></A
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN404"
HREF="#AEN404"
><SPAN
CLASS="footnote"
>[5]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>It should also be noted that ALTQ was superseded in OpenBSD 5.5 by a newer, all-HFSC queueing engine, see the relevant parts of <A
HREF="http://www.nostarch.com/pf3"
TARGET="_top"
>The Book of PF</A
> (3rd edition) or the <A
HREF="http://home.nuug.no/~peter/pf/newest/"
TARGET="_top"
>slides</A
>  matching my latest tutorial session for details.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN425"
HREF="#AEN425"
><SPAN
CLASS="footnote"
>[6]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>When in doubt, consult the output of the <SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/dmesg"
TARGET="_top"
>dmesg</A
></SPAN
> command, which displays the kernel message buffer.  Under most circumstances, the kernel's hardware probing and recognition messages will be intact in the message buffer
for a relatively long time after your system has finished
booting.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN469"
HREF="#AEN469"
><SPAN
CLASS="footnote"
>[7]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
> As a
footnoted aside, on OpenBSD, I tend to use
<SPAN
CLASS="APPLICATION"
><A
HREF="http://man.openbsd.org/doas"
TARGET="_top"
>doas</A
></SPAN
> (which replaced the venerable
<SPAN
CLASS="APPLICATION"
>sudo</SPAN
> in the base system in OpenBSD
5.8) when I need to do something which requires extra privileges.  <SPAN
CLASS="APPLICATION"
>doas</SPAN
> is in the OpenBSD base system, while its somewhat more complicated predecessor is available via the package system on OpenBSD and is within easy reach as a port or package
elsewhere.  If you have not started using doas or sudo yet, you should.  Then
you'll avoid shooting your own foot simply because you forgot you were
root in that terminal window.  For the simple cases like the samples in this document, the two commands are essentially interchangeable, but the samples from this point on will use doas to show some OpenBSD bias. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN475"
HREF="#AEN475"
><SPAN
CLASS="footnote"
>[8]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>For
convenience if you want it - <SPAN
CLASS="APPLICATION"
>pfctl</SPAN
> is able
to handle several operations on a single command line. You can, for
example, enable PF and load the rule set with the command
<KBD
CLASS="USERINPUT"
>doas pfctl -ef /etc/pf.conf</KBD
>, and bunch on
several other options if you like.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN489"
HREF="#AEN489"
><SPAN
CLASS="footnote"
>[9]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>There are some differences between the
FreeBSD 4.n and 5.n and newer releases with respect to PF.  Refer to
the FreeBSD Handbook, specifically <A
HREF="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/firewalls-pf.html"
TARGET="_top"
>the
PF chapter</A
> to see which information applies in your
case.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN499"
HREF="#AEN499"
><SPAN
CLASS="footnote"
>[10]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Here I use the <B
CLASS="COMMAND"
>sudo</B
> command, which is an excellent
tool when you need to do something which requires privileges.
<B
CLASS="COMMAND"
>sudo</B
> is not part of the base system on FreeBSD, but
is within easy reach from the ports system as
<TT
CLASS="FILENAME"
>security/sudo</TT
>.  If you have not
started using sudo (or the modern equivalent from OpenBSD <A
HREF="http://man.openbsd.org/doas"
TARGET="_top"
>doas</A
>) yet, you should.  Then you'll avoid shooting your
own foot simply because you forgot you were root in that terminal
window.  </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN563"
HREF="#AEN563"
><SPAN
CLASS="footnote"
>[11]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>In fact the new default corresponds to
<KBD
CLASS="USERINPUT"
>keep state flags S/SA</KBD
>, ensuring that only
initial SYN packets during connection setup create state, eliminating
some puzzling error scenarios</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN577"
HREF="#AEN577"
><SPAN
CLASS="footnote"
>[12]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>You may ask why do I write the rule set to default
deny?  The short answer is, it gives you better control at the expense
of some thinking. The point of packet filtering is to take control,
not to run catch-up with what the bad guys do. Marcus Ranum has
written a very entertaining and informative article about this, <A
HREF="http://www.ranum.com/security/computer_security/editorials/dumb/index.html"
TARGET="_top"
>The
Six Dumbest Ideas in Computer Security</A
>, which comes highly
recommended.  It is a good read.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN641"
HREF="#AEN641"
><SPAN
CLASS="footnote"
>[13]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Here you probably notice that we no
longer have a <KBD
CLASS="USERINPUT"
>keep state</KBD
> part. Keeping state is
redundant if you are working with OpenBSD 4.1 or equivalent, but there
is actually no need to remove the specification from your rules when
upgrading your rule set from earlier versions.  To ease transition,
the examples in this tutorial will make this distinction when
needed. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN707"
HREF="#AEN707"
><SPAN
CLASS="footnote"
>[14]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>For dialup users who conventionally use some
variant of PPP for their Internet connections, the external interface
is the <TT
CLASS="FILENAME"
>tun0</TT
> pseudo-device.  Broadband users such
as ADSL subscribers tend to have an Ethernet interface to play with,
however for a significant subset of ADSL users, specifically those
using PPP over Ethernet (PPPoE), the correct external interface will
be the <TT
CLASS="FILENAME"
>tun0</TT
> pseudo-device, not the physical
Ethernet interface.  </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN852"
HREF="#AEN852"
><SPAN
CLASS="footnote"
>[15]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>You may
need to enable <SPAN
CLASS="APPLICATION"
>inetd</SPAN
> by adding a
<KBD
CLASS="USERINPUT"
>inetd_enable="YES"</KBD
> line to your
<TT
CLASS="FILENAME"
>rc.conf</TT
> and possibly adjust other
<SPAN
CLASS="APPLICATION"
>inetd</SPAN
> related configuration
settings.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1026"
HREF="#AEN1026"
><SPAN
CLASS="footnote"
>[16]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>The main internet RFCs describing ICMP and some related
techniques are RFC792, RFC950, RFC1191, RFC1256, RFC2521, rfc2765,
while necessary updates for ICMP for IPv6 are found in RFC1885,
RFC2463, RFC2466.  These documents are available in a number of places
on the net, such as the <A
HREF="http://www.ietf.org"
TARGET="_top"
>ietf.org</A
> and <A
HREF="http://www.faqs.org"
TARGET="_top"
>faqs.org</A
> web sites, and probably
also via your package system.</P
><P
>It is quite possible that I will return to ICMP filtering in a future
advanced section of the tutorial.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1097"
HREF="#AEN1097"
><SPAN
CLASS="footnote"
>[17]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>See <A
HREF="http://www.openbsd.org/faq/pf/rdr.html#reflect"
TARGET="_top"
>Redirection and
Reflection</A
> in the PF user guide.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1149"
HREF="#AEN1149"
><SPAN
CLASS="footnote"
>[18]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>One improvement you could consider is rewriting the <KBD
CLASS="USERINPUT"
>martians</KBD
> macro from <A
HREF="#UNROUTEABLES"
>the Section called <I
>Handling non-routable addresses from elsewhere</I
> in the Chapter called <I
>Network hygiene: Blocking, scrubbing and so on</I
></A
> as a table</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1166"
HREF="#AEN1166"
><SPAN
CLASS="footnote"
>[19]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>In PF implementations based on OpenBSD 3.7 and earlier, the keyword for this was <KBD
CLASS="USERINPUT"
>log-all</KBD
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1281"
HREF="#AEN1281"
><SPAN
CLASS="footnote"
>[20]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>See <A
HREF="http://www.netbsd.org/Documentation/network/pf.html"
TARGET="_top"
>The NetBSD PF documentation</A
> for details.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1304"
HREF="#AEN1304"
><SPAN
CLASS="footnote"
>[21]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>On FreeBSD, ALTQ requires the ALTQ and queue discipline options for the disciplines
you want to use to be compiled
into the running kernel. Refer to  
<A
HREF="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/firewalls-pf.html"
TARGET="_top"
>the PF chapter</A
> 
of the FreeBSD Handbook for further information.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1307"
HREF="#AEN1307"
><SPAN
CLASS="footnote"
>[22]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>At the time of writing, ALTQ was integrated in 
the NetBSD's PF in time for the 4.0 release.  For up to date
information on this see <A
HREF="http://www.netbsd.org/Documentation/network/pf.html"
TARGET="_top"
>The NetBSD PF documentation</A
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1321"
HREF="#AEN1321"
><SPAN
CLASS="footnote"
>[23]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Earlier versions of this
tutorial left the explanation pretty much as an exercise to the
reader.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1398"
HREF="#AEN1398"
><SPAN
CLASS="footnote"
>[24]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Wireless network support in OpenBSD and BSDs
in general is getting better all the time, but this does not mean that
getting all the bits you need is necessarily easy. A brief history of
my home network goes like this: I started out buying two CNet CWP-854
cards, which should be supported in OpenBSD 3.7 via the new ral
driver.  The one I put in the brand new Dell machine running a
non-free operating system worked right out of the box.  My gateway,
which had been running without incident since the 3.3 days however,
was a little more problematic.  The card did get recognized and
configured, but once the Dell tried to get an IP address, the gateway
went down with a kernel panic.  The gory details are available as
OpenBSD PR number 4217.  I have promised to test the card again with a
new snapshot - as soon as I can locate the card again.  From the Dell we could see
an amazing number of networks, almost all unsecured, but that's
another story entirely.</P
><P
>I decided i wanted to try <A
HREF="http://man.openbsd.org/ath"
TARGET="_top"
>ath</A
> cards, and bought a
D-Link DWL-G520, which I then managed to misplace while moving house.
Next, I bought a DWL-G520+, thinking that the plus sign must mean it's
better.  Unfortunately, the plus meant a whole different chipset was
used, the TI ACX111, which comes with a low price tag but with no
documentation accessible to free software developers.  Fortunately the
store let me return the card for a refund with no trouble at all.  At
this point, I was getting rather frustrated, and went all across town
to a shop which had several DWL-AG520 cards in stock.  It was a bit
more expensive than the others, but it did work right away.  A couple
of weeks later the G520 turned up, and of course that worked too.  My
laptop (which at the time ran FreeBSD) came with a Realtek 8180
wireless mini-PCI card built in, but for some reason I could not get
it to work.  I ended up buying DWL-AG650 cardbus card, which works
flawlessly with the <TT
CLASS="FILENAME"
>ath</TT
> driver.  In general, my
advice is, if you shop online, keep the man pages available in another
tab or window, and if you go to a physical store, make sure to tell
the clerks you will be using a BSD, and if you're not sure about the
card they are trying to sell you, see if you can borrow a machine to
browse the online man pages.  Telling the clerks up front could end up
making it easier to get a refund if the part does not work, and
telling them the card did work is good advocacy.</P
><P
>It is possibly worth noting that the <TT
CLASS="FILENAME"
>acx</TT
> driver,
introduced in OpenBSD 4.0, has brought reverse engineered support for
ACX1nn based cards to the BSDs.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1522"
HREF="#AEN1522"
><SPAN
CLASS="footnote"
>[25]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>At the time this was written, password gropers trying high ports was purely theoretical, but in early 2013, I received confirmation that such attempts were indeed happening, see <A
HREF="http://bsdly.blogspot.ca/2013/02/theres-no-protection-in-high-ports.html"
TARGET="_top"
>There's No Protection In High Ports Anymore. If Indeed There Ever Was.</A
> for a longer description.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1526"
HREF="#AEN1526"
><SPAN
CLASS="footnote"
>[26]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Introduced to FreeBSD in version
6.0</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1599"
HREF="#AEN1599"
><SPAN
CLASS="footnote"
>[27]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>as
<TT
CLASS="FILENAME"
>security/expiretable</TT
> and
<TT
CLASS="FILENAME"
>sysutils/expiretable</TT
>, respectively.  It is also worth noting that <TT
CLASS="FILENAME"
>expiretable</TT
> was removed from the OpenBSD ports tree in 2008.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1637"
HREF="#AEN1637"
><SPAN
CLASS="footnote"
>[28]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>The relevant RFCs are mainly RFC1123 and RFC2821.  If you choose to join us greylisting pedants, you will need to read these, if only for proper RFC-style background information.  Remember, temporary rejection is in fact an SMTP fault tolerance feature.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1640"
HREF="#AEN1640"
><SPAN
CLASS="footnote"
>[29]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>The original Harris paper and a number of other
useful articles and resources can be found at the <A
HREF="http://www.greylisting.org/"
TARGET="_top"
>greylisting.org</A
> web
site.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1651"
HREF="#AEN1651"
><SPAN
CLASS="footnote"
>[30]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Note that on FreeBSD, <SPAN
CLASS="APPLICATION"
>spamd</SPAN
> is a port,
<TT
CLASS="FILENAME"
>mail/spamd/</TT
>. If you are running PF on
FreeBSD 5.n or newer, you need to install the port, follow the
directions given by the port's messages and return here.</P
><P
>In particular, to use <SPAN
CLASS="APPLICATION"
>spamd</SPAN
>'s
greylisting features, you need to have a file descriptor file system
 (see <A
HREF="http://www.freebsd.org/cgi/man.cgi?query=fdescfs&#38;sektion=5"
TARGET="_top"
>fdescfs(5)</A
>)
  mounted
at <TT
CLASS="FILENAME"
>/dev/fd/</TT
>.  You do this by adding the following
line to your <TT
CLASS="FILENAME"
>/etc/fstab</TT
>:</P
><P
><PRE
CLASS="PROGRAMLISTING"
> fdescfs /dev/fd fdescfs rw 0 0</PRE
></P
><P
>and making sure the <TT
CLASS="FILENAME"
>fdescfs</TT
> code is in your
kernel, either compiled in or by loading the module via the appropriate <SPAN
CLASS="APPLICATION"
>kldload</SPAN
> command.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1739"
HREF="#AEN1739"
><SPAN
CLASS="footnote"
>[31]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Note
the rather curious local part (user name) of the address in the
message which the greylisted machine tries to deliver
here.  There is more to this story.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1795"
HREF="#AEN1795"
><SPAN
CLASS="footnote"
>[32]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>One prime example was Bob Beck's "ghosts of usenet postings past" based
traplist, which rarely contained less than 20,000+ entries.  The number
of hosts varies widely and has been as high as roughly 670,000.  At the
time of writing (mid November 2010), the list typically contained
around 55,000 entries.  While still officially in testing, the list
was made publicly available on January 30th, 2006.  The list, which to my
knowledge never did produce any false positives and was available from
<A
HREF="http://www.openbsd.org/spamd/traplist.gz"
TARGET="_top"
>http://www.openbsd.org/spamd/traplist.gz</A
>
for your <TT
CLASS="FILENAME"
>spamd.conf</TT
>, was however retired from service in May 2016 and is no longer available.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1804"
HREF="#AEN1804"
><SPAN
CLASS="footnote"
>[33]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>That address is completely bogus.  It is probably based on a
GNUS message-ID, which in turn was probably lifted from a news spool
or some unfortunate malware victim's mailbox.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1864"
HREF="#AEN1864"
><SPAN
CLASS="footnote"
>[34]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>One such report
is <A
HREF="http://marc.info/?l=openbsd-misc&#38;m=116136841831550&#38;w=2"
TARGET="_top"
>Steve
Williams' October 20th, 2006 message to the OpenBSD-misc mailing
list</A
>, where he reports that a pure greylisting configuration
immediately rid the company he worked for of approximately 95% of
their spam load.</P
></TD
></TR
></TABLE
></BODY
></HTML
>